// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "simulation.h"

// geometric_t
// 

geometric_t::
geometric_t (value v)
: ::xml_schema::string (_xsd_geometric_t_literals_[v])
{
}

geometric_t::
geometric_t (const char* v)
: ::xml_schema::string (v)
{
}

geometric_t::
geometric_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

geometric_t::
geometric_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

geometric_t::
geometric_t (const geometric_t& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

geometric_t& geometric_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_geometric_t_literals_[v]);

  return *this;
}


// border_single_t
// 

border_single_t::
border_single_t (value v)
: ::xml_schema::string (_xsd_border_single_t_literals_[v])
{
}

border_single_t::
border_single_t (const char* v)
: ::xml_schema::string (v)
{
}

border_single_t::
border_single_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

border_single_t::
border_single_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

border_single_t::
border_single_t (const border_single_t& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

border_single_t& border_single_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_border_single_t_literals_[v]);

  return *this;
}


// border_t
// 

const border_t::left_type& border_t::
left () const
{
  return this->left_.get ();
}

border_t::left_type& border_t::
left ()
{
  return this->left_.get ();
}

void border_t::
left (const left_type& x)
{
  this->left_.set (x);
}

void border_t::
left (::std::unique_ptr< left_type > x)
{
  this->left_.set (std::move (x));
}

const border_t::right_type& border_t::
right () const
{
  return this->right_.get ();
}

border_t::right_type& border_t::
right ()
{
  return this->right_.get ();
}

void border_t::
right (const right_type& x)
{
  this->right_.set (x);
}

void border_t::
right (::std::unique_ptr< right_type > x)
{
  this->right_.set (std::move (x));
}

const border_t::upper_type& border_t::
upper () const
{
  return this->upper_.get ();
}

border_t::upper_type& border_t::
upper ()
{
  return this->upper_.get ();
}

void border_t::
upper (const upper_type& x)
{
  this->upper_.set (x);
}

void border_t::
upper (::std::unique_ptr< upper_type > x)
{
  this->upper_.set (std::move (x));
}

const border_t::lower_type& border_t::
lower () const
{
  return this->lower_.get ();
}

border_t::lower_type& border_t::
lower ()
{
  return this->lower_.get ();
}

void border_t::
lower (const lower_type& x)
{
  this->lower_.set (x);
}

void border_t::
lower (::std::unique_ptr< lower_type > x)
{
  this->lower_.set (std::move (x));
}

const border_t::front_optional& border_t::
front () const
{
  return this->front_;
}

border_t::front_optional& border_t::
front ()
{
  return this->front_;
}

void border_t::
front (const front_type& x)
{
  this->front_.set (x);
}

void border_t::
front (const front_optional& x)
{
  this->front_ = x;
}

void border_t::
front (::std::unique_ptr< front_type > x)
{
  this->front_.set (std::move (x));
}

const border_t::back_optional& border_t::
back () const
{
  return this->back_;
}

border_t::back_optional& border_t::
back ()
{
  return this->back_;
}

void border_t::
back (const back_type& x)
{
  this->back_.set (x);
}

void border_t::
back (const back_optional& x)
{
  this->back_ = x;
}

void border_t::
back (::std::unique_ptr< back_type > x)
{
  this->back_.set (std::move (x));
}


// generator_info_t
// 

const generator_info_t::x_type& generator_info_t::
x () const
{
  return this->x_.get ();
}

generator_info_t::x_type& generator_info_t::
x ()
{
  return this->x_.get ();
}

void generator_info_t::
x (const x_type& x)
{
  this->x_.set (x);
}

const generator_info_t::y_type& generator_info_t::
y () const
{
  return this->y_.get ();
}

generator_info_t::y_type& generator_info_t::
y ()
{
  return this->y_.get ();
}

void generator_info_t::
y (const y_type& x)
{
  this->y_.set (x);
}

const generator_info_t::z_type& generator_info_t::
z () const
{
  return this->z_.get ();
}

generator_info_t::z_type& generator_info_t::
z ()
{
  return this->z_.get ();
}

void generator_info_t::
z (const z_type& x)
{
  this->z_.set (x);
}

const generator_info_t::v1_type& generator_info_t::
v1 () const
{
  return this->v1_.get ();
}

generator_info_t::v1_type& generator_info_t::
v1 ()
{
  return this->v1_.get ();
}

void generator_info_t::
v1 (const v1_type& x)
{
  this->v1_.set (x);
}

const generator_info_t::v2_type& generator_info_t::
v2 () const
{
  return this->v2_.get ();
}

generator_info_t::v2_type& generator_info_t::
v2 ()
{
  return this->v2_.get ();
}

void generator_info_t::
v2 (const v2_type& x)
{
  this->v2_.set (x);
}

const generator_info_t::v3_type& generator_info_t::
v3 () const
{
  return this->v3_.get ();
}

generator_info_t::v3_type& generator_info_t::
v3 ()
{
  return this->v3_.get ();
}

void generator_info_t::
v3 (const v3_type& x)
{
  this->v3_.set (x);
}

const generator_info_t::mass_type& generator_info_t::
mass () const
{
  return this->mass_.get ();
}

generator_info_t::mass_type& generator_info_t::
mass ()
{
  return this->mass_.get ();
}

void generator_info_t::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const generator_info_t::epsilon_type& generator_info_t::
epsilon () const
{
  return this->epsilon_.get ();
}

generator_info_t::epsilon_type& generator_info_t::
epsilon ()
{
  return this->epsilon_.get ();
}

void generator_info_t::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

const generator_info_t::sigma_type& generator_info_t::
sigma () const
{
  return this->sigma_.get ();
}

generator_info_t::sigma_type& generator_info_t::
sigma ()
{
  return this->sigma_.get ();
}

void generator_info_t::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

const generator_info_t::distance_type& generator_info_t::
distance () const
{
  return this->distance_.get ();
}

generator_info_t::distance_type& generator_info_t::
distance ()
{
  return this->distance_.get ();
}

void generator_info_t::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

const generator_info_t::brownianFactor_type& generator_info_t::
brownianFactor () const
{
  return this->brownianFactor_.get ();
}

generator_info_t::brownianFactor_type& generator_info_t::
brownianFactor ()
{
  return this->brownianFactor_.get ();
}

void generator_info_t::
brownianFactor (const brownianFactor_type& x)
{
  this->brownianFactor_.set (x);
}

const generator_info_t::dim_type& generator_info_t::
dim () const
{
  return this->dim_.get ();
}

generator_info_t::dim_type& generator_info_t::
dim ()
{
  return this->dim_.get ();
}

void generator_info_t::
dim (const dim_type& x)
{
  this->dim_.set (x);
}

const generator_info_t::n1_optional& generator_info_t::
n1 () const
{
  return this->n1_;
}

generator_info_t::n1_optional& generator_info_t::
n1 ()
{
  return this->n1_;
}

void generator_info_t::
n1 (const n1_type& x)
{
  this->n1_.set (x);
}

void generator_info_t::
n1 (const n1_optional& x)
{
  this->n1_ = x;
}

const generator_info_t::n2_optional& generator_info_t::
n2 () const
{
  return this->n2_;
}

generator_info_t::n2_optional& generator_info_t::
n2 ()
{
  return this->n2_;
}

void generator_info_t::
n2 (const n2_type& x)
{
  this->n2_.set (x);
}

void generator_info_t::
n2 (const n2_optional& x)
{
  this->n2_ = x;
}

const generator_info_t::n3_optional& generator_info_t::
n3 () const
{
  return this->n3_;
}

generator_info_t::n3_optional& generator_info_t::
n3 ()
{
  return this->n3_;
}

void generator_info_t::
n3 (const n3_type& x)
{
  this->n3_.set (x);
}

void generator_info_t::
n3 (const n3_optional& x)
{
  this->n3_ = x;
}

const generator_info_t::radius_optional& generator_info_t::
radius () const
{
  return this->radius_;
}

generator_info_t::radius_optional& generator_info_t::
radius ()
{
  return this->radius_;
}

void generator_info_t::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void generator_info_t::
radius (const radius_optional& x)
{
  this->radius_ = x;
}

const generator_info_t::type_type& generator_info_t::
type () const
{
  return this->type_.get ();
}

generator_info_t::type_type& generator_info_t::
type ()
{
  return this->type_.get ();
}

void generator_info_t::
type (const type_type& x)
{
  this->type_.set (x);
}

void generator_info_t::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// containertype_t
// 

containertype_t::
containertype_t (value v)
: ::xml_schema::string (_xsd_containertype_t_literals_[v])
{
}

containertype_t::
containertype_t (const char* v)
: ::xml_schema::string (v)
{
}

containertype_t::
containertype_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

containertype_t::
containertype_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

containertype_t::
containertype_t (const containertype_t& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

containertype_t& containertype_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_containertype_t_literals_[v]);

  return *this;
}


// calculatortype_t
// 

calculatortype_t::
calculatortype_t (value v)
: ::xml_schema::string (_xsd_calculatortype_t_literals_[v])
{
}

calculatortype_t::
calculatortype_t (const char* v)
: ::xml_schema::string (v)
{
}

calculatortype_t::
calculatortype_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

calculatortype_t::
calculatortype_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

calculatortype_t::
calculatortype_t (const calculatortype_t& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

calculatortype_t& calculatortype_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_calculatortype_t_literals_[v]);

  return *this;
}


// containerinfo_t
// 

const containerinfo_t::rCut_optional& containerinfo_t::
rCut () const
{
  return this->rCut_;
}

containerinfo_t::rCut_optional& containerinfo_t::
rCut ()
{
  return this->rCut_;
}

void containerinfo_t::
rCut (const rCut_type& x)
{
  this->rCut_.set (x);
}

void containerinfo_t::
rCut (const rCut_optional& x)
{
  this->rCut_ = x;
}

const containerinfo_t::domainSizeX_optional& containerinfo_t::
domainSizeX () const
{
  return this->domainSizeX_;
}

containerinfo_t::domainSizeX_optional& containerinfo_t::
domainSizeX ()
{
  return this->domainSizeX_;
}

void containerinfo_t::
domainSizeX (const domainSizeX_type& x)
{
  this->domainSizeX_.set (x);
}

void containerinfo_t::
domainSizeX (const domainSizeX_optional& x)
{
  this->domainSizeX_ = x;
}

const containerinfo_t::domainSizeY_optional& containerinfo_t::
domainSizeY () const
{
  return this->domainSizeY_;
}

containerinfo_t::domainSizeY_optional& containerinfo_t::
domainSizeY ()
{
  return this->domainSizeY_;
}

void containerinfo_t::
domainSizeY (const domainSizeY_type& x)
{
  this->domainSizeY_.set (x);
}

void containerinfo_t::
domainSizeY (const domainSizeY_optional& x)
{
  this->domainSizeY_ = x;
}

const containerinfo_t::domainSizeZ_optional& containerinfo_t::
domainSizeZ () const
{
  return this->domainSizeZ_;
}

containerinfo_t::domainSizeZ_optional& containerinfo_t::
domainSizeZ ()
{
  return this->domainSizeZ_;
}

void containerinfo_t::
domainSizeZ (const domainSizeZ_type& x)
{
  this->domainSizeZ_.set (x);
}

void containerinfo_t::
domainSizeZ (const domainSizeZ_optional& x)
{
  this->domainSizeZ_ = x;
}

const containerinfo_t::borderType_optional& containerinfo_t::
borderType () const
{
  return this->borderType_;
}

containerinfo_t::borderType_optional& containerinfo_t::
borderType ()
{
  return this->borderType_;
}

void containerinfo_t::
borderType (const borderType_type& x)
{
  this->borderType_.set (x);
}

void containerinfo_t::
borderType (const borderType_optional& x)
{
  this->borderType_ = x;
}

void containerinfo_t::
borderType (::std::unique_ptr< borderType_type > x)
{
  this->borderType_.set (std::move (x));
}

const containerinfo_t::type_type& containerinfo_t::
type () const
{
  return this->type_.get ();
}

containerinfo_t::type_type& containerinfo_t::
type ()
{
  return this->type_.get ();
}

void containerinfo_t::
type (const type_type& x)
{
  this->type_.set (x);
}

void containerinfo_t::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// calculationInfo_t
// 

const calculationInfo_t::epsilon_optional& calculationInfo_t::
epsilon () const
{
  return this->epsilon_;
}

calculationInfo_t::epsilon_optional& calculationInfo_t::
epsilon ()
{
  return this->epsilon_;
}

void calculationInfo_t::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

void calculationInfo_t::
epsilon (const epsilon_optional& x)
{
  this->epsilon_ = x;
}

const calculationInfo_t::sigma_optional& calculationInfo_t::
sigma () const
{
  return this->sigma_;
}

calculationInfo_t::sigma_optional& calculationInfo_t::
sigma ()
{
  return this->sigma_;
}

void calculationInfo_t::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

void calculationInfo_t::
sigma (const sigma_optional& x)
{
  this->sigma_ = x;
}

const calculationInfo_t::gravityFactor_optional& calculationInfo_t::
gravityFactor () const
{
  return this->gravityFactor_;
}

calculationInfo_t::gravityFactor_optional& calculationInfo_t::
gravityFactor ()
{
  return this->gravityFactor_;
}

void calculationInfo_t::
gravityFactor (const gravityFactor_type& x)
{
  this->gravityFactor_.set (x);
}

void calculationInfo_t::
gravityFactor (const gravityFactor_optional& x)
{
  this->gravityFactor_ = x;
}

const calculationInfo_t::brownianMotion_optional& calculationInfo_t::
brownianMotion () const
{
  return this->brownianMotion_;
}

calculationInfo_t::brownianMotion_optional& calculationInfo_t::
brownianMotion ()
{
  return this->brownianMotion_;
}

void calculationInfo_t::
brownianMotion (const brownianMotion_type& x)
{
  this->brownianMotion_.set (x);
}

void calculationInfo_t::
brownianMotion (const brownianMotion_optional& x)
{
  this->brownianMotion_ = x;
}

const calculationInfo_t::type_type& calculationInfo_t::
type () const
{
  return this->type_.get ();
}

calculationInfo_t::type_type& calculationInfo_t::
type ()
{
  return this->type_.get ();
}

void calculationInfo_t::
type (const type_type& x)
{
  this->type_.set (x);
}

void calculationInfo_t::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// outputwriter_t
// 

outputwriter_t::
outputwriter_t (value v)
: ::xml_schema::string (_xsd_outputwriter_t_literals_[v])
{
}

outputwriter_t::
outputwriter_t (const char* v)
: ::xml_schema::string (v)
{
}

outputwriter_t::
outputwriter_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

outputwriter_t::
outputwriter_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

outputwriter_t::
outputwriter_t (const outputwriter_t& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

outputwriter_t& outputwriter_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_outputwriter_t_literals_[v]);

  return *this;
}


// simulation_t
// 

const simulation_t::container_type& simulation_t::
container () const
{
  return this->container_.get ();
}

simulation_t::container_type& simulation_t::
container ()
{
  return this->container_.get ();
}

void simulation_t::
container (const container_type& x)
{
  this->container_.set (x);
}

void simulation_t::
container (::std::unique_ptr< container_type > x)
{
  this->container_.set (std::move (x));
}

const simulation_t::calculator_type& simulation_t::
calculator () const
{
  return this->calculator_.get ();
}

simulation_t::calculator_type& simulation_t::
calculator ()
{
  return this->calculator_.get ();
}

void simulation_t::
calculator (const calculator_type& x)
{
  this->calculator_.set (x);
}

void simulation_t::
calculator (::std::unique_ptr< calculator_type > x)
{
  this->calculator_.set (std::move (x));
}

const simulation_t::inputFile_sequence& simulation_t::
inputFile () const
{
  return this->inputFile_;
}

simulation_t::inputFile_sequence& simulation_t::
inputFile ()
{
  return this->inputFile_;
}

void simulation_t::
inputFile (const inputFile_sequence& s)
{
  this->inputFile_ = s;
}

const simulation_t::generatorFile_sequence& simulation_t::
generatorFile () const
{
  return this->generatorFile_;
}

simulation_t::generatorFile_sequence& simulation_t::
generatorFile ()
{
  return this->generatorFile_;
}

void simulation_t::
generatorFile (const generatorFile_sequence& s)
{
  this->generatorFile_ = s;
}

const simulation_t::outputFile_type& simulation_t::
outputFile () const
{
  return this->outputFile_.get ();
}

simulation_t::outputFile_type& simulation_t::
outputFile ()
{
  return this->outputFile_.get ();
}

void simulation_t::
outputFile (const outputFile_type& x)
{
  this->outputFile_.set (x);
}

void simulation_t::
outputFile (::std::unique_ptr< outputFile_type > x)
{
  this->outputFile_.set (std::move (x));
}

const simulation_t::generatorInfo_sequence& simulation_t::
generatorInfo () const
{
  return this->generatorInfo_;
}

simulation_t::generatorInfo_sequence& simulation_t::
generatorInfo ()
{
  return this->generatorInfo_;
}

void simulation_t::
generatorInfo (const generatorInfo_sequence& s)
{
  this->generatorInfo_ = s;
}

const simulation_t::t_end_type& simulation_t::
t_end () const
{
  return this->t_end_.get ();
}

simulation_t::t_end_type& simulation_t::
t_end ()
{
  return this->t_end_.get ();
}

void simulation_t::
t_end (const t_end_type& x)
{
  this->t_end_.set (x);
}

const simulation_t::delta_t_type& simulation_t::
delta_t () const
{
  return this->delta_t_.get ();
}

simulation_t::delta_t_type& simulation_t::
delta_t ()
{
  return this->delta_t_.get ();
}

void simulation_t::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

const simulation_t::writeFrequency_type& simulation_t::
writeFrequency () const
{
  return this->writeFrequency_.get ();
}

simulation_t::writeFrequency_type& simulation_t::
writeFrequency ()
{
  return this->writeFrequency_.get ();
}

void simulation_t::
writeFrequency (const writeFrequency_type& x)
{
  this->writeFrequency_.set (x);
}

const simulation_t::outputWriter_type& simulation_t::
outputWriter () const
{
  return this->outputWriter_.get ();
}

simulation_t::outputWriter_type& simulation_t::
outputWriter ()
{
  return this->outputWriter_.get ();
}

void simulation_t::
outputWriter (const outputWriter_type& x)
{
  this->outputWriter_.set (x);
}

void simulation_t::
outputWriter (::std::unique_ptr< outputWriter_type > x)
{
  this->outputWriter_.set (std::move (x));
}

const simulation_t::random_optional& simulation_t::
random () const
{
  return this->random_;
}

simulation_t::random_optional& simulation_t::
random ()
{
  return this->random_;
}

void simulation_t::
random (const random_type& x)
{
  this->random_.set (x);
}

void simulation_t::
random (const random_optional& x)
{
  this->random_ = x;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// geometric_t
//

geometric_t::
geometric_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_geometric_t_convert ();
}

geometric_t::
geometric_t (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_geometric_t_convert ();
}

geometric_t::
geometric_t (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_geometric_t_convert ();
}

geometric_t* geometric_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class geometric_t (*this, f, c);
}

geometric_t::value geometric_t::
_xsd_geometric_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_geometric_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_geometric_t_indexes_,
                    _xsd_geometric_t_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_geometric_t_indexes_ + 2 || _xsd_geometric_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const geometric_t::
_xsd_geometric_t_literals_[2] =
{
  "cuboid",
  "sphere"
};

const geometric_t::value geometric_t::
_xsd_geometric_t_indexes_[2] =
{
  ::geometric_t::cuboid,
  ::geometric_t::sphere
};

// border_single_t
//

border_single_t::
border_single_t (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_border_single_t_convert ();
}

border_single_t::
border_single_t (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_border_single_t_convert ();
}

border_single_t::
border_single_t (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_border_single_t_convert ();
}

border_single_t* border_single_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class border_single_t (*this, f, c);
}

border_single_t::value border_single_t::
_xsd_border_single_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_border_single_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_border_single_t_indexes_,
                    _xsd_border_single_t_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_border_single_t_indexes_ + 3 || _xsd_border_single_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const border_single_t::
_xsd_border_single_t_literals_[3] =
{
  "periodic",
  "reflective",
  "outflow"
};

const border_single_t::value border_single_t::
_xsd_border_single_t_indexes_[3] =
{
  ::border_single_t::outflow,
  ::border_single_t::periodic,
  ::border_single_t::reflective
};

// border_t
//

border_t::
border_t (const left_type& left,
          const right_type& right,
          const upper_type& upper,
          const lower_type& lower)
: ::xml_schema::type (),
  left_ (left, this),
  right_ (right, this),
  upper_ (upper, this),
  lower_ (lower, this),
  front_ (this),
  back_ (this)
{
}

border_t::
border_t (const border_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  left_ (x.left_, f, this),
  right_ (x.right_, f, this),
  upper_ (x.upper_, f, this),
  lower_ (x.lower_, f, this),
  front_ (x.front_, f, this),
  back_ (x.back_, f, this)
{
}

border_t::
border_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  left_ (this),
  right_ (this),
  upper_ (this),
  lower_ (this),
  front_ (this),
  back_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void border_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< left_type > r (
        left_traits::create (i, f, this));

      if (!left_.present ())
      {
        this->left_.set (::std::move (r));
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< right_type > r (
        right_traits::create (i, f, this));

      if (!right_.present ())
      {
        this->right_.set (::std::move (r));
        continue;
      }
    }

    // upper
    //
    if (n.name () == "upper" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< upper_type > r (
        upper_traits::create (i, f, this));

      if (!upper_.present ())
      {
        this->upper_.set (::std::move (r));
        continue;
      }
    }

    // lower
    //
    if (n.name () == "lower" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lower_type > r (
        lower_traits::create (i, f, this));

      if (!lower_.present ())
      {
        this->lower_.set (::std::move (r));
        continue;
      }
    }

    // front
    //
    if (n.name () == "front" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< front_type > r (
        front_traits::create (i, f, this));

      if (!this->front_)
      {
        this->front_.set (::std::move (r));
        continue;
      }
    }

    // back
    //
    if (n.name () == "back" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< back_type > r (
        back_traits::create (i, f, this));

      if (!this->back_)
      {
        this->back_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!left_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "left",
      "");
  }

  if (!right_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "right",
      "");
  }

  if (!upper_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "upper",
      "");
  }

  if (!lower_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "lower",
      "");
  }
}

border_t* border_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class border_t (*this, f, c);
}

border_t& border_t::
operator= (const border_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->left_ = x.left_;
    this->right_ = x.right_;
    this->upper_ = x.upper_;
    this->lower_ = x.lower_;
    this->front_ = x.front_;
    this->back_ = x.back_;
  }

  return *this;
}

border_t::
~border_t ()
{
}

// generator_info_t
//

generator_info_t::
generator_info_t (const x_type& x,
                  const y_type& y,
                  const z_type& z,
                  const v1_type& v1,
                  const v2_type& v2,
                  const v3_type& v3,
                  const mass_type& mass,
                  const epsilon_type& epsilon,
                  const sigma_type& sigma,
                  const distance_type& distance,
                  const brownianFactor_type& brownianFactor,
                  const dim_type& dim,
                  const type_type& type)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this),
  v1_ (v1, this),
  v2_ (v2, this),
  v3_ (v3, this),
  mass_ (mass, this),
  epsilon_ (epsilon, this),
  sigma_ (sigma, this),
  distance_ (distance, this),
  brownianFactor_ (brownianFactor, this),
  dim_ (dim, this),
  n1_ (this),
  n2_ (this),
  n3_ (this),
  radius_ (this),
  type_ (type, this)
{
}

generator_info_t::
generator_info_t (const generator_info_t& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this),
  v1_ (x.v1_, f, this),
  v2_ (x.v2_, f, this),
  v3_ (x.v3_, f, this),
  mass_ (x.mass_, f, this),
  epsilon_ (x.epsilon_, f, this),
  sigma_ (x.sigma_, f, this),
  distance_ (x.distance_, f, this),
  brownianFactor_ (x.brownianFactor_, f, this),
  dim_ (x.dim_, f, this),
  n1_ (x.n1_, f, this),
  n2_ (x.n2_, f, this),
  n3_ (x.n3_, f, this),
  radius_ (x.radius_, f, this),
  type_ (x.type_, f, this)
{
}

generator_info_t::
generator_info_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this),
  v1_ (this),
  v2_ (this),
  v3_ (this),
  mass_ (this),
  epsilon_ (this),
  sigma_ (this),
  distance_ (this),
  brownianFactor_ (this),
  dim_ (this),
  n1_ (this),
  n2_ (this),
  n3_ (this),
  radius_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void generator_info_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    // v1
    //
    if (n.name () == "v1" && n.namespace_ ().empty ())
    {
      if (!v1_.present ())
      {
        this->v1_.set (v1_traits::create (i, f, this));
        continue;
      }
    }

    // v2
    //
    if (n.name () == "v2" && n.namespace_ ().empty ())
    {
      if (!v2_.present ())
      {
        this->v2_.set (v2_traits::create (i, f, this));
        continue;
      }
    }

    // v3
    //
    if (n.name () == "v3" && n.namespace_ ().empty ())
    {
      if (!v3_.present ())
      {
        this->v3_.set (v3_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!epsilon_.present ())
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      if (!sigma_.present ())
      {
        this->sigma_.set (sigma_traits::create (i, f, this));
        continue;
      }
    }

    // distance
    //
    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      if (!distance_.present ())
      {
        this->distance_.set (distance_traits::create (i, f, this));
        continue;
      }
    }

    // brownianFactor
    //
    if (n.name () == "brownianFactor" && n.namespace_ ().empty ())
    {
      if (!brownianFactor_.present ())
      {
        this->brownianFactor_.set (brownianFactor_traits::create (i, f, this));
        continue;
      }
    }

    // dim
    //
    if (n.name () == "dim" && n.namespace_ ().empty ())
    {
      if (!dim_.present ())
      {
        this->dim_.set (dim_traits::create (i, f, this));
        continue;
      }
    }

    // n1
    //
    if (n.name () == "n1" && n.namespace_ ().empty ())
    {
      if (!this->n1_)
      {
        this->n1_.set (n1_traits::create (i, f, this));
        continue;
      }
    }

    // n2
    //
    if (n.name () == "n2" && n.namespace_ ().empty ())
    {
      if (!this->n2_)
      {
        this->n2_.set (n2_traits::create (i, f, this));
        continue;
      }
    }

    // n3
    //
    if (n.name () == "n3" && n.namespace_ ().empty ())
    {
      if (!this->n3_)
      {
        this->n3_.set (n3_traits::create (i, f, this));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!this->radius_)
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }

  if (!v1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "v1",
      "");
  }

  if (!v2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "v2",
      "");
  }

  if (!v3_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "v3",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sigma",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "distance",
      "");
  }

  if (!brownianFactor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "brownianFactor",
      "");
  }

  if (!dim_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dim",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

generator_info_t* generator_info_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class generator_info_t (*this, f, c);
}

generator_info_t& generator_info_t::
operator= (const generator_info_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
    this->v1_ = x.v1_;
    this->v2_ = x.v2_;
    this->v3_ = x.v3_;
    this->mass_ = x.mass_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
    this->distance_ = x.distance_;
    this->brownianFactor_ = x.brownianFactor_;
    this->dim_ = x.dim_;
    this->n1_ = x.n1_;
    this->n2_ = x.n2_;
    this->n3_ = x.n3_;
    this->radius_ = x.radius_;
    this->type_ = x.type_;
  }

  return *this;
}

generator_info_t::
~generator_info_t ()
{
}

// containertype_t
//

containertype_t::
containertype_t (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_containertype_t_convert ();
}

containertype_t::
containertype_t (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_containertype_t_convert ();
}

containertype_t::
containertype_t (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_containertype_t_convert ();
}

containertype_t* containertype_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class containertype_t (*this, f, c);
}

containertype_t::value containertype_t::
_xsd_containertype_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_containertype_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_containertype_t_indexes_,
                    _xsd_containertype_t_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_containertype_t_indexes_ + 2 || _xsd_containertype_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const containertype_t::
_xsd_containertype_t_literals_[2] =
{
  "linkedcell",
  "directsum"
};

const containertype_t::value containertype_t::
_xsd_containertype_t_indexes_[2] =
{
  ::containertype_t::directsum,
  ::containertype_t::linkedcell
};

// calculatortype_t
//

calculatortype_t::
calculatortype_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_calculatortype_t_convert ();
}

calculatortype_t::
calculatortype_t (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_calculatortype_t_convert ();
}

calculatortype_t::
calculatortype_t (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_calculatortype_t_convert ();
}

calculatortype_t* calculatortype_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class calculatortype_t (*this, f, c);
}

calculatortype_t::value calculatortype_t::
_xsd_calculatortype_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_calculatortype_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_calculatortype_t_indexes_,
                    _xsd_calculatortype_t_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_calculatortype_t_indexes_ + 2 || _xsd_calculatortype_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const calculatortype_t::
_xsd_calculatortype_t_literals_[2] =
{
  "lennardjones",
  "gravitation"
};

const calculatortype_t::value calculatortype_t::
_xsd_calculatortype_t_indexes_[2] =
{
  ::calculatortype_t::gravitation,
  ::calculatortype_t::lennardjones
};

// containerinfo_t
//

containerinfo_t::
containerinfo_t (const type_type& type)
: ::xml_schema::type (),
  rCut_ (this),
  domainSizeX_ (this),
  domainSizeY_ (this),
  domainSizeZ_ (this),
  borderType_ (this),
  type_ (type, this)
{
}

containerinfo_t::
containerinfo_t (const containerinfo_t& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  rCut_ (x.rCut_, f, this),
  domainSizeX_ (x.domainSizeX_, f, this),
  domainSizeY_ (x.domainSizeY_, f, this),
  domainSizeZ_ (x.domainSizeZ_, f, this),
  borderType_ (x.borderType_, f, this),
  type_ (x.type_, f, this)
{
}

containerinfo_t::
containerinfo_t (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  rCut_ (this),
  domainSizeX_ (this),
  domainSizeY_ (this),
  domainSizeZ_ (this),
  borderType_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void containerinfo_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // rCut
    //
    if (n.name () == "rCut" && n.namespace_ ().empty ())
    {
      if (!this->rCut_)
      {
        this->rCut_.set (rCut_traits::create (i, f, this));
        continue;
      }
    }

    // domainSizeX
    //
    if (n.name () == "domainSizeX" && n.namespace_ ().empty ())
    {
      if (!this->domainSizeX_)
      {
        this->domainSizeX_.set (domainSizeX_traits::create (i, f, this));
        continue;
      }
    }

    // domainSizeY
    //
    if (n.name () == "domainSizeY" && n.namespace_ ().empty ())
    {
      if (!this->domainSizeY_)
      {
        this->domainSizeY_.set (domainSizeY_traits::create (i, f, this));
        continue;
      }
    }

    // domainSizeZ
    //
    if (n.name () == "domainSizeZ" && n.namespace_ ().empty ())
    {
      if (!this->domainSizeZ_)
      {
        this->domainSizeZ_.set (domainSizeZ_traits::create (i, f, this));
        continue;
      }
    }

    // borderType
    //
    if (n.name () == "borderType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< borderType_type > r (
        borderType_traits::create (i, f, this));

      if (!this->borderType_)
      {
        this->borderType_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

containerinfo_t* containerinfo_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class containerinfo_t (*this, f, c);
}

containerinfo_t& containerinfo_t::
operator= (const containerinfo_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->rCut_ = x.rCut_;
    this->domainSizeX_ = x.domainSizeX_;
    this->domainSizeY_ = x.domainSizeY_;
    this->domainSizeZ_ = x.domainSizeZ_;
    this->borderType_ = x.borderType_;
    this->type_ = x.type_;
  }

  return *this;
}

containerinfo_t::
~containerinfo_t ()
{
}

// calculationInfo_t
//

calculationInfo_t::
calculationInfo_t (const type_type& type)
: ::xml_schema::type (),
  epsilon_ (this),
  sigma_ (this),
  gravityFactor_ (this),
  brownianMotion_ (this),
  type_ (type, this)
{
}

calculationInfo_t::
calculationInfo_t (const calculationInfo_t& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  epsilon_ (x.epsilon_, f, this),
  sigma_ (x.sigma_, f, this),
  gravityFactor_ (x.gravityFactor_, f, this),
  brownianMotion_ (x.brownianMotion_, f, this),
  type_ (x.type_, f, this)
{
}

calculationInfo_t::
calculationInfo_t (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  epsilon_ (this),
  sigma_ (this),
  gravityFactor_ (this),
  brownianMotion_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void calculationInfo_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!this->epsilon_)
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      if (!this->sigma_)
      {
        this->sigma_.set (sigma_traits::create (i, f, this));
        continue;
      }
    }

    // gravityFactor
    //
    if (n.name () == "gravityFactor" && n.namespace_ ().empty ())
    {
      if (!this->gravityFactor_)
      {
        this->gravityFactor_.set (gravityFactor_traits::create (i, f, this));
        continue;
      }
    }

    // brownianMotion
    //
    if (n.name () == "brownianMotion" && n.namespace_ ().empty ())
    {
      if (!this->brownianMotion_)
      {
        this->brownianMotion_.set (brownianMotion_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

calculationInfo_t* calculationInfo_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class calculationInfo_t (*this, f, c);
}

calculationInfo_t& calculationInfo_t::
operator= (const calculationInfo_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
    this->gravityFactor_ = x.gravityFactor_;
    this->brownianMotion_ = x.brownianMotion_;
    this->type_ = x.type_;
  }

  return *this;
}

calculationInfo_t::
~calculationInfo_t ()
{
}

// outputwriter_t
//

outputwriter_t::
outputwriter_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_outputwriter_t_convert ();
}

outputwriter_t::
outputwriter_t (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_outputwriter_t_convert ();
}

outputwriter_t::
outputwriter_t (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_outputwriter_t_convert ();
}

outputwriter_t* outputwriter_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class outputwriter_t (*this, f, c);
}

outputwriter_t::value outputwriter_t::
_xsd_outputwriter_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_outputwriter_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_outputwriter_t_indexes_,
                    _xsd_outputwriter_t_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_outputwriter_t_indexes_ + 2 || _xsd_outputwriter_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const outputwriter_t::
_xsd_outputwriter_t_literals_[2] =
{
  "vtk",
  "xyz"
};

const outputwriter_t::value outputwriter_t::
_xsd_outputwriter_t_indexes_[2] =
{
  ::outputwriter_t::vtk,
  ::outputwriter_t::xyz
};

// simulation_t
//

simulation_t::
simulation_t (const container_type& container,
              const calculator_type& calculator,
              const outputFile_type& outputFile,
              const t_end_type& t_end,
              const delta_t_type& delta_t,
              const writeFrequency_type& writeFrequency,
              const outputWriter_type& outputWriter)
: ::xml_schema::type (),
  container_ (container, this),
  calculator_ (calculator, this),
  inputFile_ (this),
  generatorFile_ (this),
  outputFile_ (outputFile, this),
  generatorInfo_ (this),
  t_end_ (t_end, this),
  delta_t_ (delta_t, this),
  writeFrequency_ (writeFrequency, this),
  outputWriter_ (outputWriter, this),
  random_ (this)
{
}

simulation_t::
simulation_t (::std::unique_ptr< container_type > container,
              ::std::unique_ptr< calculator_type > calculator,
              const outputFile_type& outputFile,
              const t_end_type& t_end,
              const delta_t_type& delta_t,
              const writeFrequency_type& writeFrequency,
              const outputWriter_type& outputWriter)
: ::xml_schema::type (),
  container_ (std::move (container), this),
  calculator_ (std::move (calculator), this),
  inputFile_ (this),
  generatorFile_ (this),
  outputFile_ (outputFile, this),
  generatorInfo_ (this),
  t_end_ (t_end, this),
  delta_t_ (delta_t, this),
  writeFrequency_ (writeFrequency, this),
  outputWriter_ (outputWriter, this),
  random_ (this)
{
}

simulation_t::
simulation_t (const simulation_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  container_ (x.container_, f, this),
  calculator_ (x.calculator_, f, this),
  inputFile_ (x.inputFile_, f, this),
  generatorFile_ (x.generatorFile_, f, this),
  outputFile_ (x.outputFile_, f, this),
  generatorInfo_ (x.generatorInfo_, f, this),
  t_end_ (x.t_end_, f, this),
  delta_t_ (x.delta_t_, f, this),
  writeFrequency_ (x.writeFrequency_, f, this),
  outputWriter_ (x.outputWriter_, f, this),
  random_ (x.random_, f, this)
{
}

simulation_t::
simulation_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  container_ (this),
  calculator_ (this),
  inputFile_ (this),
  generatorFile_ (this),
  outputFile_ (this),
  generatorInfo_ (this),
  t_end_ (this),
  delta_t_ (this),
  writeFrequency_ (this),
  outputWriter_ (this),
  random_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void simulation_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // container
    //
    if (n.name () == "container" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< container_type > r (
        container_traits::create (i, f, this));

      if (!container_.present ())
      {
        this->container_.set (::std::move (r));
        continue;
      }
    }

    // calculator
    //
    if (n.name () == "calculator" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< calculator_type > r (
        calculator_traits::create (i, f, this));

      if (!calculator_.present ())
      {
        this->calculator_.set (::std::move (r));
        continue;
      }
    }

    // inputFile
    //
    if (n.name () == "inputFile" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< inputFile_type > r (
        inputFile_traits::create (i, f, this));

      this->inputFile_.push_back (::std::move (r));
      continue;
    }

    // generatorFile
    //
    if (n.name () == "generatorFile" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< generatorFile_type > r (
        generatorFile_traits::create (i, f, this));

      this->generatorFile_.push_back (::std::move (r));
      continue;
    }

    // outputFile
    //
    if (n.name () == "outputFile" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< outputFile_type > r (
        outputFile_traits::create (i, f, this));

      if (!outputFile_.present ())
      {
        this->outputFile_.set (::std::move (r));
        continue;
      }
    }

    // generatorInfo
    //
    if (n.name () == "generatorInfo" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< generatorInfo_type > r (
        generatorInfo_traits::create (i, f, this));

      this->generatorInfo_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!container_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "container",
      "");
  }

  if (!calculator_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "calculator",
      "");
  }

  if (!outputFile_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "outputFile",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "t_end" && n.namespace_ ().empty ())
    {
      this->t_end_.set (t_end_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      this->delta_t_.set (delta_t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "writeFrequency" && n.namespace_ ().empty ())
    {
      this->writeFrequency_.set (writeFrequency_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "outputWriter" && n.namespace_ ().empty ())
    {
      this->outputWriter_.set (outputWriter_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "random" && n.namespace_ ().empty ())
    {
      this->random_.set (random_traits::create (i, f, this));
      continue;
    }
  }

  if (!t_end_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t_end",
      "");
  }

  if (!delta_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "delta_t",
      "");
  }

  if (!writeFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "writeFrequency",
      "");
  }

  if (!outputWriter_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "outputWriter",
      "");
  }
}

simulation_t* simulation_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulation_t (*this, f, c);
}

simulation_t& simulation_t::
operator= (const simulation_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->container_ = x.container_;
    this->calculator_ = x.calculator_;
    this->inputFile_ = x.inputFile_;
    this->generatorFile_ = x.generatorFile_;
    this->outputFile_ = x.outputFile_;
    this->generatorInfo_ = x.generatorInfo_;
    this->t_end_ = x.t_end_;
    this->delta_t_ = x.delta_t_;
    this->writeFrequency_ = x.writeFrequency_;
    this->outputWriter_ = x.outputWriter_;
    this->random_ = x.random_;
  }

  return *this;
}

simulation_t::
~simulation_t ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::simulation_t >
simulation (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
simulation (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
simulation (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
simulation (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation (isrc, f, p);
}

::std::unique_ptr< ::simulation_t >
simulation (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation (isrc, h, f, p);
}

::std::unique_ptr< ::simulation_t >
simulation (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation (isrc, h, f, p);
}

::std::unique_ptr< ::simulation_t >
simulation (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation (isrc, f, p);
}

::std::unique_ptr< ::simulation_t >
simulation (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation (isrc, h, f, p);
}

::std::unique_ptr< ::simulation_t >
simulation (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation (isrc, h, f, p);
}

::std::unique_ptr< ::simulation_t >
simulation (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
simulation (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
simulation (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
simulation (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::simulation_t > (
      ::simulation (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::simulation_t > r (
      ::xsd::cxx::tree::traits< ::simulation_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

::std::unique_ptr< ::simulation_t >
simulation (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::simulation_t > r (
      ::xsd::cxx::tree::traits< ::simulation_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const geometric_t& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const geometric_t& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const geometric_t& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const border_single_t& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const border_single_t& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const border_single_t& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const border_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // left
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "left",
        e));

    s << i.left ();
  }

  // right
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "right",
        e));

    s << i.right ();
  }

  // upper
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "upper",
        e));

    s << i.upper ();
  }

  // lower
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "lower",
        e));

    s << i.lower ();
  }

  // front
  //
  if (i.front ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "front",
        e));

    s << *i.front ();
  }

  // back
  //
  if (i.back ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "back",
        e));

    s << *i.back ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const generator_info_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "x",
        e));

    s << ::xml_schema::as_decimal(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "y",
        e));

    s << ::xml_schema::as_decimal(i.y ());
  }

  // z
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "z",
        e));

    s << ::xml_schema::as_decimal(i.z ());
  }

  // v1
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "v1",
        e));

    s << ::xml_schema::as_decimal(i.v1 ());
  }

  // v2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "v2",
        e));

    s << ::xml_schema::as_decimal(i.v2 ());
  }

  // v3
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "v3",
        e));

    s << ::xml_schema::as_decimal(i.v3 ());
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mass",
        e));

    s << ::xml_schema::as_decimal(i.mass ());
  }

  // epsilon
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "epsilon",
        e));

    s << ::xml_schema::as_decimal(i.epsilon ());
  }

  // sigma
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sigma",
        e));

    s << ::xml_schema::as_decimal(i.sigma ());
  }

  // distance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "distance",
        e));

    s << ::xml_schema::as_decimal(i.distance ());
  }

  // brownianFactor
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "brownianFactor",
        e));

    s << ::xml_schema::as_decimal(i.brownianFactor ());
  }

  // dim
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dim",
        e));

    s << i.dim ();
  }

  // n1
  //
  if (i.n1 ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "n1",
        e));

    s << *i.n1 ();
  }

  // n2
  //
  if (i.n2 ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "n2",
        e));

    s << *i.n2 ();
  }

  // n3
  //
  if (i.n3 ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "n3",
        e));

    s << *i.n3 ();
  }

  // radius
  //
  if (i.radius ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "radius",
        e));

    s << *i.radius ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const containertype_t& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const containertype_t& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const containertype_t& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const calculatortype_t& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const calculatortype_t& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const calculatortype_t& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const containerinfo_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // rCut
  //
  if (i.rCut ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "rCut",
        e));

    s << ::xml_schema::as_decimal(*i.rCut ());
  }

  // domainSizeX
  //
  if (i.domainSizeX ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "domainSizeX",
        e));

    s << *i.domainSizeX ();
  }

  // domainSizeY
  //
  if (i.domainSizeY ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "domainSizeY",
        e));

    s << *i.domainSizeY ();
  }

  // domainSizeZ
  //
  if (i.domainSizeZ ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "domainSizeZ",
        e));

    s << *i.domainSizeZ ();
  }

  // borderType
  //
  if (i.borderType ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "borderType",
        e));

    s << *i.borderType ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const calculationInfo_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // epsilon
  //
  if (i.epsilon ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "epsilon",
        e));

    s << ::xml_schema::as_decimal(*i.epsilon ());
  }

  // sigma
  //
  if (i.sigma ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sigma",
        e));

    s << ::xml_schema::as_decimal(*i.sigma ());
  }

  // gravityFactor
  //
  if (i.gravityFactor ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "gravityFactor",
        e));

    s << ::xml_schema::as_decimal(*i.gravityFactor ());
  }

  // brownianMotion
  //
  if (i.brownianMotion ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "brownianMotion",
        e));

    s << ::xml_schema::as_decimal(*i.brownianMotion ());
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const outputwriter_t& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const outputwriter_t& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const outputwriter_t& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const simulation_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // container
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "container",
        e));

    s << i.container ();
  }

  // calculator
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "calculator",
        e));

    s << i.calculator ();
  }

  // inputFile
  //
  for (simulation_t::inputFile_const_iterator
       b (i.inputFile ().begin ()), n (i.inputFile ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "inputFile",
        e));

    s << *b;
  }

  // generatorFile
  //
  for (simulation_t::generatorFile_const_iterator
       b (i.generatorFile ().begin ()), n (i.generatorFile ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "generatorFile",
        e));

    s << *b;
  }

  // outputFile
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "outputFile",
        e));

    s << i.outputFile ();
  }

  // generatorInfo
  //
  for (simulation_t::generatorInfo_const_iterator
       b (i.generatorInfo ().begin ()), n (i.generatorInfo ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "generatorInfo",
        e));

    s << *b;
  }

  // t_end
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "t_end",
        e));

    a << ::xml_schema::as_decimal(i.t_end ());
  }

  // delta_t
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "delta_t",
        e));

    a << ::xml_schema::as_decimal(i.delta_t ());
  }

  // writeFrequency
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "writeFrequency",
        e));

    a << i.writeFrequency ();
  }

  // outputWriter
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "outputWriter",
        e));

    a << i.outputWriter ();
  }

  // random
  //
  if (i.random ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "random",
        e));

    a << *i.random ();
  }
}

void
simulation (::std::ostream& o,
            const ::simulation_t& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
simulation (::std::ostream& o,
            const ::simulation_t& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation (::std::ostream& o,
            const ::simulation_t& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation (::xercesc::XMLFormatTarget& t,
            const ::simulation_t& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
simulation (::xercesc::XMLFormatTarget& t,
            const ::simulation_t& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation (::xercesc::XMLFormatTarget& t,
            const ::simulation_t& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::simulation (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation (::xercesc::DOMDocument& d,
            const ::simulation_t& s,
            ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "simulation",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
simulation (const ::simulation_t& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "simulation",
      "",
      m, f));

  ::simulation (*d, s, f);
  return d;
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

