// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from simulation.xsd.
 */

#ifndef SIMULATION_H
#define SIMULATION_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char unsigned_byte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short short_;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short unsigned_short;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int int_;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int unsigned_int;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long long_;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long unsigned_long;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long non_positive_integer;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long non_negative_integer;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long positive_integer;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long negative_integer;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float float_;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double double_;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, simple_type > string;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, token > name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, token > language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, ncname > id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone time_zone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, simple_type > date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, simple_type > time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class geometric_t;
class border_single_t;
class border_t;
class behaviour_t;
class generator_info_t;
class containertype_t;
class calculatortype_t;
class containerinfo_t;
class calculationInfo_t;
class outputwriter_t;
class thermostat_info_t;
class statistics_type_t;
class statistics_t;
class array_int_3;
class array_float_3;
class special_particle_t;
class simulation_t;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

/**
 * @brief Enumeration class corresponding to the %geometric_t
 * schema type.
 */
class geometric_t: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    cuboid,
    sphere
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  geometric_t (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  geometric_t (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  geometric_t (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  geometric_t (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  geometric_t (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  geometric_t (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  geometric_t (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  geometric_t (const geometric_t& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual geometric_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  geometric_t&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_geometric_t_convert ();
  }

  //@cond

  protected:
  value
  _xsd_geometric_t_convert () const;

  public:
  static const char* const _xsd_geometric_t_literals_[2];
  static const value _xsd_geometric_t_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %border_single_t
 * schema type.
 */
class border_single_t: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    periodic,
    reflective,
    outflow
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  border_single_t (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  border_single_t (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  border_single_t (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  border_single_t (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  border_single_t (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  border_single_t (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  border_single_t (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  border_single_t (const border_single_t& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual border_single_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  border_single_t&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_border_single_t_convert ();
  }

  //@cond

  protected:
  value
  _xsd_border_single_t_convert () const;

  public:
  static const char* const _xsd_border_single_t_literals_[3];
  static const value _xsd_border_single_t_indexes_[3];

  //@endcond
};

/**
 * @brief Class corresponding to the %border_t schema type.
 *
 * @nosubgrouping
 */
class border_t: public ::xml_schema::type
{
  public:
  /**
   * @name left
   *
   * @brief Accessor and modifier functions for the %left
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::border_single_t left_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< left_type, char > left_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const left_type&
  left () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  left_type&
  left ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  left (const left_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  left (::std::unique_ptr< left_type > p);

  //@}

  /**
   * @name right
   *
   * @brief Accessor and modifier functions for the %right
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::border_single_t right_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< right_type, char > right_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const right_type&
  right () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  right_type&
  right ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  right (const right_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  right (::std::unique_ptr< right_type > p);

  //@}

  /**
   * @name upper
   *
   * @brief Accessor and modifier functions for the %upper
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::border_single_t upper_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< upper_type, char > upper_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const upper_type&
  upper () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  upper_type&
  upper ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  upper (const upper_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  upper (::std::unique_ptr< upper_type > p);

  //@}

  /**
   * @name lower
   *
   * @brief Accessor and modifier functions for the %lower
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::border_single_t lower_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< lower_type, char > lower_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const lower_type&
  lower () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  lower_type&
  lower ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  lower (const lower_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  lower (::std::unique_ptr< lower_type > p);

  //@}

  /**
   * @name front
   *
   * @brief Accessor and modifier functions for the %front
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::border_single_t front_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< front_type > front_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< front_type, char > front_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const front_optional&
  front () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  front_optional&
  front ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  front (const front_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  front (const front_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  front (::std::unique_ptr< front_type > p);

  //@}

  /**
   * @name back
   *
   * @brief Accessor and modifier functions for the %back
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::border_single_t back_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< back_type > back_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< back_type, char > back_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const back_optional&
  back () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  back_optional&
  back ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  back (const back_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  back (const back_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  back (::std::unique_ptr< back_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  border_t (const left_type&,
            const right_type&,
            const upper_type&,
            const lower_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  border_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  border_t (const border_t& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual border_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  border_t&
  operator= (const border_t& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~border_t ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< left_type > left_;
  ::xsd::cxx::tree::one< right_type > right_;
  ::xsd::cxx::tree::one< upper_type > upper_;
  ::xsd::cxx::tree::one< lower_type > lower_;
  front_optional front_;
  back_optional back_;

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %behaviour_t
 * schema type.
 */
class behaviour_t: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    normal,
    membrane,
    immovable
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  behaviour_t (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  behaviour_t (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  behaviour_t (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  behaviour_t (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  behaviour_t (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  behaviour_t (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  behaviour_t (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  behaviour_t (const behaviour_t& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual behaviour_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  behaviour_t&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_behaviour_t_convert ();
  }

  //@cond

  protected:
  value
  _xsd_behaviour_t_convert () const;

  public:
  static const char* const _xsd_behaviour_t_literals_[3];
  static const value _xsd_behaviour_t_indexes_[3];

  //@endcond
};

/**
 * @brief Class corresponding to the %generator_info_t schema type.
 *
 * @nosubgrouping
 */
class generator_info_t: public ::xml_schema::type
{
  public:
  /**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal x_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::decimal > x_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const x_type&
  x () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  x_type&
  x ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  x (const x_type& x);

  //@}

  /**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal y_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::decimal > y_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const y_type&
  y () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  y_type&
  y ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  y (const y_type& x);

  //@}

  /**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal z_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::decimal > z_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const z_type&
  z () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  z_type&
  z ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  z (const z_type& x);

  //@}

  /**
   * @name v1
   *
   * @brief Accessor and modifier functions for the %v1
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal v1_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< v1_type, char, ::xsd::cxx::tree::schema_type::decimal > v1_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const v1_type&
  v1 () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  v1_type&
  v1 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  v1 (const v1_type& x);

  //@}

  /**
   * @name v2
   *
   * @brief Accessor and modifier functions for the %v2
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal v2_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< v2_type, char, ::xsd::cxx::tree::schema_type::decimal > v2_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const v2_type&
  v2 () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  v2_type&
  v2 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  v2 (const v2_type& x);

  //@}

  /**
   * @name v3
   *
   * @brief Accessor and modifier functions for the %v3
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal v3_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< v3_type, char, ::xsd::cxx::tree::schema_type::decimal > v3_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const v3_type&
  v3 () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  v3_type&
  v3 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  v3 (const v3_type& x);

  //@}

  /**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal mass_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< mass_type, char, ::xsd::cxx::tree::schema_type::decimal > mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const mass_type&
  mass () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  mass_type&
  mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  mass (const mass_type& x);

  //@}

  /**
   * @name epsilon
   *
   * @brief Accessor and modifier functions for the %epsilon
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal epsilon_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< epsilon_type, char, ::xsd::cxx::tree::schema_type::decimal > epsilon_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const epsilon_type&
  epsilon () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  epsilon_type&
  epsilon ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  epsilon (const epsilon_type& x);

  //@}

  /**
   * @name sigma
   *
   * @brief Accessor and modifier functions for the %sigma
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal sigma_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< sigma_type, char, ::xsd::cxx::tree::schema_type::decimal > sigma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const sigma_type&
  sigma () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  sigma_type&
  sigma ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  sigma (const sigma_type& x);

  //@}

  /**
   * @name distance
   *
   * @brief Accessor and modifier functions for the %distance
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal distance_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< distance_type, char, ::xsd::cxx::tree::schema_type::decimal > distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const distance_type&
  distance () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  distance_type&
  distance ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  distance (const distance_type& x);

  //@}

  /**
   * @name brownianFactor
   *
   * @brief Accessor and modifier functions for the %brownianFactor
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal brownianFactor_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< brownianFactor_type, char, ::xsd::cxx::tree::schema_type::decimal > brownianFactor_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const brownianFactor_type&
  brownianFactor () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  brownianFactor_type&
  brownianFactor ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  brownianFactor (const brownianFactor_type& x);

  //@}

  /**
   * @name dim
   *
   * @brief Accessor and modifier functions for the %dim
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ dim_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< dim_type, char > dim_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const dim_type&
  dim () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  dim_type&
  dim ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  dim (const dim_type& x);

  //@}

  /**
   * @name n1
   *
   * @brief Accessor and modifier functions for the %n1
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ n1_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< n1_type > n1_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< n1_type, char > n1_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const n1_optional&
  n1 () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  n1_optional&
  n1 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  n1 (const n1_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  n1 (const n1_optional& x);

  //@}

  /**
   * @name n2
   *
   * @brief Accessor and modifier functions for the %n2
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ n2_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< n2_type > n2_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< n2_type, char > n2_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const n2_optional&
  n2 () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  n2_optional&
  n2 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  n2 (const n2_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  n2 (const n2_optional& x);

  //@}

  /**
   * @name n3
   *
   * @brief Accessor and modifier functions for the %n3
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ n3_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< n3_type > n3_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< n3_type, char > n3_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const n3_optional&
  n3 () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  n3_optional&
  n3 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  n3 (const n3_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  n3 (const n3_optional& x);

  //@}

  /**
   * @name radius
   *
   * @brief Accessor and modifier functions for the %radius
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ radius_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< radius_type > radius_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< radius_type, char > radius_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const radius_optional&
  radius () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  radius_optional&
  radius ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  radius (const radius_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  radius (const radius_optional& x);

  //@}

  /**
   * @name special_particle
   *
   * @brief Accessor and modifier functions for the %special_particle
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::special_particle_t special_particle_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< special_particle_type > special_particle_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef special_particle_sequence::iterator special_particle_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef special_particle_sequence::const_iterator special_particle_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< special_particle_type, char > special_particle_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const special_particle_sequence&
  special_particle () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  special_particle_sequence&
  special_particle ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  special_particle (const special_particle_sequence& s);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::geometric_t type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type&
  type () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type&
  type ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  type (const type_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  type (::std::unique_ptr< type_type > p);

  //@}

  /**
   * @name behaviour
   *
   * @brief Accessor and modifier functions for the %behaviour
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::behaviour_t behaviour_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< behaviour_type > behaviour_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< behaviour_type, char > behaviour_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const behaviour_optional&
  behaviour () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  behaviour_optional&
  behaviour ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  behaviour (const behaviour_type& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  behaviour (const behaviour_optional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  behaviour (::std::unique_ptr< behaviour_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  generator_info_t (const x_type&,
                    const y_type&,
                    const z_type&,
                    const v1_type&,
                    const v2_type&,
                    const v3_type&,
                    const mass_type&,
                    const epsilon_type&,
                    const sigma_type&,
                    const distance_type&,
                    const brownianFactor_type&,
                    const dim_type&,
                    const type_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  generator_info_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  generator_info_t (const generator_info_t& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual generator_info_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  generator_info_t&
  operator= (const generator_info_t& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~generator_info_t ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< z_type > z_;
  ::xsd::cxx::tree::one< v1_type > v1_;
  ::xsd::cxx::tree::one< v2_type > v2_;
  ::xsd::cxx::tree::one< v3_type > v3_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  ::xsd::cxx::tree::one< epsilon_type > epsilon_;
  ::xsd::cxx::tree::one< sigma_type > sigma_;
  ::xsd::cxx::tree::one< distance_type > distance_;
  ::xsd::cxx::tree::one< brownianFactor_type > brownianFactor_;
  ::xsd::cxx::tree::one< dim_type > dim_;
  n1_optional n1_;
  n2_optional n2_;
  n3_optional n3_;
  radius_optional radius_;
  special_particle_sequence special_particle_;
  ::xsd::cxx::tree::one< type_type > type_;
  behaviour_optional behaviour_;

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %containertype_t
 * schema type.
 */
class containertype_t: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    linkedcell,
    directsum
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  containertype_t (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  containertype_t (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  containertype_t (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  containertype_t (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  containertype_t (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  containertype_t (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  containertype_t (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  containertype_t (const containertype_t& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual containertype_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  containertype_t&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_containertype_t_convert ();
  }

  //@cond

  protected:
  value
  _xsd_containertype_t_convert () const;

  public:
  static const char* const _xsd_containertype_t_literals_[2];
  static const value _xsd_containertype_t_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %calculatortype_t
 * schema type.
 */
class calculatortype_t: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    lennardjones,
    gravitation
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  calculatortype_t (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  calculatortype_t (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  calculatortype_t (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  calculatortype_t (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  calculatortype_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  calculatortype_t (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  calculatortype_t (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  calculatortype_t (const calculatortype_t& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual calculatortype_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  calculatortype_t&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_calculatortype_t_convert ();
  }

  //@cond

  protected:
  value
  _xsd_calculatortype_t_convert () const;

  public:
  static const char* const _xsd_calculatortype_t_literals_[2];
  static const value _xsd_calculatortype_t_indexes_[2];

  //@endcond
};

/**
 * @brief Class corresponding to the %containerinfo_t schema type.
 *
 * @nosubgrouping
 */
class containerinfo_t: public ::xml_schema::type
{
  public:
  /**
   * @name rCut
   *
   * @brief Accessor and modifier functions for the %rCut
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal rCut_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< rCut_type > rCut_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< rCut_type, char, ::xsd::cxx::tree::schema_type::decimal > rCut_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const rCut_optional&
  rCut () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  rCut_optional&
  rCut ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  rCut (const rCut_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  rCut (const rCut_optional& x);

  //@}

  /**
   * @name domainSizeX
   *
   * @brief Accessor and modifier functions for the %domainSizeX
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal domainSizeX_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< domainSizeX_type > domainSizeX_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< domainSizeX_type, char, ::xsd::cxx::tree::schema_type::decimal > domainSizeX_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const domainSizeX_optional&
  domainSizeX () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  domainSizeX_optional&
  domainSizeX ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  domainSizeX (const domainSizeX_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  domainSizeX (const domainSizeX_optional& x);

  //@}

  /**
   * @name domainSizeY
   *
   * @brief Accessor and modifier functions for the %domainSizeY
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal domainSizeY_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< domainSizeY_type > domainSizeY_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< domainSizeY_type, char, ::xsd::cxx::tree::schema_type::decimal > domainSizeY_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const domainSizeY_optional&
  domainSizeY () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  domainSizeY_optional&
  domainSizeY ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  domainSizeY (const domainSizeY_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  domainSizeY (const domainSizeY_optional& x);

  //@}

  /**
   * @name domainSizeZ
   *
   * @brief Accessor and modifier functions for the %domainSizeZ
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal domainSizeZ_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< domainSizeZ_type > domainSizeZ_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< domainSizeZ_type, char, ::xsd::cxx::tree::schema_type::decimal > domainSizeZ_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const domainSizeZ_optional&
  domainSizeZ () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  domainSizeZ_optional&
  domainSizeZ ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  domainSizeZ (const domainSizeZ_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  domainSizeZ (const domainSizeZ_optional& x);

  //@}

  /**
   * @name borderType
   *
   * @brief Accessor and modifier functions for the %borderType
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::border_t borderType_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< borderType_type > borderType_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< borderType_type, char > borderType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const borderType_optional&
  borderType () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  borderType_optional&
  borderType ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  borderType (const borderType_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  borderType (const borderType_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  borderType (::std::unique_ptr< borderType_type > p);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::containertype_t type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type&
  type () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type&
  type ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  type (const type_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  type (::std::unique_ptr< type_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  containerinfo_t (const type_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  containerinfo_t (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  containerinfo_t (const containerinfo_t& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual containerinfo_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  containerinfo_t&
  operator= (const containerinfo_t& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~containerinfo_t ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  rCut_optional rCut_;
  domainSizeX_optional domainSizeX_;
  domainSizeY_optional domainSizeY_;
  domainSizeZ_optional domainSizeZ_;
  borderType_optional borderType_;
  ::xsd::cxx::tree::one< type_type > type_;

  //@endcond
};

/**
 * @brief Class corresponding to the %calculationInfo_t schema type.
 *
 * @nosubgrouping
 */
class calculationInfo_t: public ::xml_schema::type
{
  public:
  /**
   * @name epsilon
   *
   * @brief Accessor and modifier functions for the %epsilon
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal epsilon_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< epsilon_type > epsilon_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< epsilon_type, char, ::xsd::cxx::tree::schema_type::decimal > epsilon_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const epsilon_optional&
  epsilon () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  epsilon_optional&
  epsilon ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  epsilon (const epsilon_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  epsilon (const epsilon_optional& x);

  //@}

  /**
   * @name sigma
   *
   * @brief Accessor and modifier functions for the %sigma
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal sigma_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< sigma_type > sigma_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< sigma_type, char, ::xsd::cxx::tree::schema_type::decimal > sigma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const sigma_optional&
  sigma () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  sigma_optional&
  sigma ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  sigma (const sigma_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  sigma (const sigma_optional& x);

  //@}

  /**
   * @name gravityFactor
   *
   * @brief Accessor and modifier functions for the %gravityFactor
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::array_float_3 gravityFactor_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< gravityFactor_type > gravityFactor_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< gravityFactor_type, char > gravityFactor_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const gravityFactor_optional&
  gravityFactor () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  gravityFactor_optional&
  gravityFactor ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  gravityFactor (const gravityFactor_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  gravityFactor (const gravityFactor_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  gravityFactor (::std::unique_ptr< gravityFactor_type > p);

  //@}

  /**
   * @name brownianMotion
   *
   * @brief Accessor and modifier functions for the %brownianMotion
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal brownianMotion_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< brownianMotion_type > brownianMotion_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< brownianMotion_type, char, ::xsd::cxx::tree::schema_type::decimal > brownianMotion_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const brownianMotion_optional&
  brownianMotion () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  brownianMotion_optional&
  brownianMotion ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  brownianMotion (const brownianMotion_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  brownianMotion (const brownianMotion_optional& x);

  //@}

  /**
   * @name baseForceTime
   *
   * @brief Accessor and modifier functions for the %baseForceTime
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal baseForceTime_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< baseForceTime_type > baseForceTime_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< baseForceTime_type, char, ::xsd::cxx::tree::schema_type::decimal > baseForceTime_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const baseForceTime_optional&
  baseForceTime () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  baseForceTime_optional&
  baseForceTime ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  baseForceTime (const baseForceTime_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  baseForceTime (const baseForceTime_optional& x);

  //@}

  /**
   * @name rZero
   *
   * @brief Accessor and modifier functions for the %rZero
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal rZero_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< rZero_type > rZero_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< rZero_type, char, ::xsd::cxx::tree::schema_type::decimal > rZero_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const rZero_optional&
  rZero () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  rZero_optional&
  rZero ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  rZero (const rZero_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  rZero (const rZero_optional& x);

  //@}

  /**
   * @name stiffnessConstant
   *
   * @brief Accessor and modifier functions for the %stiffnessConstant
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal stiffnessConstant_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< stiffnessConstant_type > stiffnessConstant_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< stiffnessConstant_type, char, ::xsd::cxx::tree::schema_type::decimal > stiffnessConstant_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const stiffnessConstant_optional&
  stiffnessConstant () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  stiffnessConstant_optional&
  stiffnessConstant ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  stiffnessConstant (const stiffnessConstant_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  stiffnessConstant (const stiffnessConstant_optional& x);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::calculatortype_t type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type&
  type () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type&
  type ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  type (const type_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  type (::std::unique_ptr< type_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  calculationInfo_t (const type_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  calculationInfo_t (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  calculationInfo_t (const calculationInfo_t& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual calculationInfo_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  calculationInfo_t&
  operator= (const calculationInfo_t& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~calculationInfo_t ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  epsilon_optional epsilon_;
  sigma_optional sigma_;
  gravityFactor_optional gravityFactor_;
  brownianMotion_optional brownianMotion_;
  baseForceTime_optional baseForceTime_;
  rZero_optional rZero_;
  stiffnessConstant_optional stiffnessConstant_;
  ::xsd::cxx::tree::one< type_type > type_;

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %outputwriter_t
 * schema type.
 */
class outputwriter_t: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    vtk,
    xyz
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  outputwriter_t (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  outputwriter_t (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  outputwriter_t (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  outputwriter_t (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  outputwriter_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  outputwriter_t (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  outputwriter_t (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  outputwriter_t (const outputwriter_t& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual outputwriter_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  outputwriter_t&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_outputwriter_t_convert ();
  }

  //@cond

  protected:
  value
  _xsd_outputwriter_t_convert () const;

  public:
  static const char* const _xsd_outputwriter_t_literals_[2];
  static const value _xsd_outputwriter_t_indexes_[2];

  //@endcond
};

/**
 * @brief Class corresponding to the %thermostat_info_t schema type.
 *
 * @nosubgrouping
 */
class thermostat_info_t: public ::xml_schema::type
{
  public:
  /**
   * @name nThermostat
   *
   * @brief Accessor and modifier functions for the %nThermostat
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ nThermostat_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nThermostat_type, char > nThermostat_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const nThermostat_type&
  nThermostat () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  nThermostat_type&
  nThermostat ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nThermostat (const nThermostat_type& x);

  //@}

  /**
   * @name Tinit
   *
   * @brief Accessor and modifier functions for the %Tinit
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Tinit_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Tinit_type, char, ::xsd::cxx::tree::schema_type::decimal > Tinit_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Tinit_type&
  Tinit () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Tinit_type&
  Tinit ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Tinit (const Tinit_type& x);

  //@}

  /**
   * @name Ttarget
   *
   * @brief Accessor and modifier functions for the %Ttarget
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Ttarget_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Ttarget_type > Ttarget_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Ttarget_type, char, ::xsd::cxx::tree::schema_type::decimal > Ttarget_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Ttarget_optional&
  Ttarget () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Ttarget_optional&
  Ttarget ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Ttarget (const Ttarget_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Ttarget (const Ttarget_optional& x);

  //@}

  /**
   * @name deltaTemp
   *
   * @brief Accessor and modifier functions for the %deltaTemp
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal deltaTemp_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< deltaTemp_type > deltaTemp_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< deltaTemp_type, char, ::xsd::cxx::tree::schema_type::decimal > deltaTemp_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const deltaTemp_optional&
  deltaTemp () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  deltaTemp_optional&
  deltaTemp ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  deltaTemp (const deltaTemp_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  deltaTemp (const deltaTemp_optional& x);

  //@}

  /**
   * @name excludeY
   *
   * @brief Accessor and modifier functions for the %excludeY
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::boolean excludeY_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< excludeY_type > excludeY_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< excludeY_type, char > excludeY_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const excludeY_optional&
  excludeY () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  excludeY_optional&
  excludeY ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  excludeY (const excludeY_type& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  excludeY (const excludeY_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  thermostat_info_t (const nThermostat_type&,
                     const Tinit_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  thermostat_info_t (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  thermostat_info_t (const thermostat_info_t& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual thermostat_info_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  thermostat_info_t&
  operator= (const thermostat_info_t& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~thermostat_info_t ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< nThermostat_type > nThermostat_;
  ::xsd::cxx::tree::one< Tinit_type > Tinit_;
  Ttarget_optional Ttarget_;
  deltaTemp_optional deltaTemp_;
  excludeY_optional excludeY_;

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %statistics_type_t
 * schema type.
 */
class statistics_type_t: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    thermodynamical,
    densityVelocity
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  statistics_type_t (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  statistics_type_t (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  statistics_type_t (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  statistics_type_t (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  statistics_type_t (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  statistics_type_t (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  statistics_type_t (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  statistics_type_t (const statistics_type_t& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual statistics_type_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  statistics_type_t&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_statistics_type_t_convert ();
  }

  //@cond

  protected:
  value
  _xsd_statistics_type_t_convert () const;

  public:
  static const char* const _xsd_statistics_type_t_literals_[2];
  static const value _xsd_statistics_type_t_indexes_[2];

  //@endcond
};

/**
 * @brief Class corresponding to the %statistics_t schema type.
 *
 * @nosubgrouping
 */
class statistics_t: public ::xml_schema::type
{
  public:
  /**
   * @name noBins
   *
   * @brief Accessor and modifier functions for the %noBins
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ noBins_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< noBins_type > noBins_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< noBins_type, char > noBins_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const noBins_optional&
  noBins () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  noBins_optional&
  noBins ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  noBins (const noBins_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  noBins (const noBins_optional& x);

  //@}

  /**
   * @name file
   *
   * @brief Accessor and modifier functions for the %file
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string file_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< file_type, char > file_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const file_type&
  file () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  file_type&
  file ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  file (const file_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  file (::std::unique_ptr< file_type > p);

  //@}

  /**
   * @name frequency
   *
   * @brief Accessor and modifier functions for the %frequency
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ frequency_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< frequency_type, char > frequency_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const frequency_type&
  frequency () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  frequency_type&
  frequency ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  frequency (const frequency_type& x);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::statistics_type_t type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type&
  type () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type&
  type ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  type (const type_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  type (::std::unique_ptr< type_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  statistics_t (const file_type&,
                const frequency_type&,
                const type_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  statistics_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  statistics_t (const statistics_t& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual statistics_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  statistics_t&
  operator= (const statistics_t& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~statistics_t ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  noBins_optional noBins_;
  ::xsd::cxx::tree::one< file_type > file_;
  ::xsd::cxx::tree::one< frequency_type > frequency_;
  ::xsd::cxx::tree::one< type_type > type_;

  //@endcond
};

/**
 * @brief Class corresponding to the %array_int_3 schema type.
 *
 * @nosubgrouping
 */
class array_int_3: public ::xml_schema::type
{
  public:
  /**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::int_ x_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const x_type&
  x () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  x_type&
  x ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  x (const x_type& x);

  //@}

  /**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::int_ y_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const y_type&
  y () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  y_type&
  y ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  y (const y_type& x);

  //@}

  /**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::int_ z_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< z_type, char > z_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const z_type&
  z () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  z_type&
  z ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  z (const z_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  array_int_3 (const x_type&,
               const y_type&,
               const z_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  array_int_3 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  array_int_3 (const array_int_3& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual array_int_3*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  array_int_3&
  operator= (const array_int_3& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~array_int_3 ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< z_type > z_;

  //@endcond
};

/**
 * @brief Class corresponding to the %array_float_3 schema type.
 *
 * @nosubgrouping
 */
class array_float_3: public ::xml_schema::type
{
  public:
  /**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::decimal x_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::decimal > x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const x_type&
  x () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  x_type&
  x ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  x (const x_type& x);

  //@}

  /**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::decimal y_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::decimal > y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const y_type&
  y () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  y_type&
  y ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  y (const y_type& x);

  //@}

  /**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::decimal z_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::decimal > z_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const z_type&
  z () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  z_type&
  z ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  z (const z_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  array_float_3 (const x_type&,
                 const y_type&,
                 const z_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  array_float_3 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  array_float_3 (const array_float_3& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual array_float_3*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  array_float_3&
  operator= (const array_float_3& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~array_float_3 ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< z_type > z_;

  //@endcond
};

/**
 * @brief Class corresponding to the %special_particle_t schema type.
 *
 * @nosubgrouping
 */
class special_particle_t: public ::xml_schema::type
{
  public:
  /**
   * @name position
   *
   * @brief Accessor and modifier functions for the %position
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::array_int_3 position_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< position_type, char > position_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const position_type&
  position () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  position_type&
  position ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  position (const position_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  position (::std::unique_ptr< position_type > p);

  //@}

  /**
   * @name force
   *
   * @brief Accessor and modifier functions for the %force
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::array_float_3 force_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< force_type > force_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< force_type, char > force_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const force_optional&
  force () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  force_optional&
  force ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  force (const force_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  force (const force_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  force (::std::unique_ptr< force_type > p);

  //@}

  /**
   * @name vel
   *
   * @brief Accessor and modifier functions for the %vel
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::array_float_3 vel_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< vel_type > vel_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< vel_type, char > vel_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const vel_optional&
  vel () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  vel_optional&
  vel ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  vel (const vel_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  vel (const vel_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  vel (::std::unique_ptr< vel_type > p);

  //@}

  /**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal mass_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< mass_type > mass_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< mass_type, char, ::xsd::cxx::tree::schema_type::decimal > mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const mass_optional&
  mass () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  mass_optional&
  mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  mass (const mass_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  mass (const mass_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  special_particle_t (const position_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  special_particle_t (::std::unique_ptr< position_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  special_particle_t (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  special_particle_t (const special_particle_t& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual special_particle_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  special_particle_t&
  operator= (const special_particle_t& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~special_particle_t ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< position_type > position_;
  force_optional force_;
  vel_optional vel_;
  mass_optional mass_;

  //@endcond
};

/**
 * @brief Class corresponding to the %simulation_t schema type.
 *
 * @nosubgrouping
 */
class simulation_t: public ::xml_schema::type
{
  public:
  /**
   * @name container
   *
   * @brief Accessor and modifier functions for the %container
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::containerinfo_t container_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< container_type, char > container_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const container_type&
  container () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  container_type&
  container ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  container (const container_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  container (::std::unique_ptr< container_type > p);

  //@}

  /**
   * @name calculator
   *
   * @brief Accessor and modifier functions for the %calculator
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::calculationInfo_t calculator_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< calculator_type, char > calculator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const calculator_type&
  calculator () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  calculator_type&
  calculator ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  calculator (const calculator_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  calculator (::std::unique_ptr< calculator_type > p);

  //@}

  /**
   * @name inputFile
   *
   * @brief Accessor and modifier functions for the %inputFile
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string inputFile_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< inputFile_type > inputFile_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef inputFile_sequence::iterator inputFile_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef inputFile_sequence::const_iterator inputFile_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< inputFile_type, char > inputFile_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const inputFile_sequence&
  inputFile () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  inputFile_sequence&
  inputFile ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  inputFile (const inputFile_sequence& s);

  //@}

  /**
   * @name generatorFile
   *
   * @brief Accessor and modifier functions for the %generatorFile
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string generatorFile_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< generatorFile_type > generatorFile_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef generatorFile_sequence::iterator generatorFile_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef generatorFile_sequence::const_iterator generatorFile_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< generatorFile_type, char > generatorFile_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const generatorFile_sequence&
  generatorFile () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  generatorFile_sequence&
  generatorFile ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  generatorFile (const generatorFile_sequence& s);

  //@}

  /**
   * @name outputFile
   *
   * @brief Accessor and modifier functions for the %outputFile
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string outputFile_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< outputFile_type, char > outputFile_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const outputFile_type&
  outputFile () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  outputFile_type&
  outputFile ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  outputFile (const outputFile_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  outputFile (::std::unique_ptr< outputFile_type > p);

  //@}

  /**
   * @name generatorInfo
   *
   * @brief Accessor and modifier functions for the %generatorInfo
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::generator_info_t generatorInfo_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< generatorInfo_type > generatorInfo_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef generatorInfo_sequence::iterator generatorInfo_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef generatorInfo_sequence::const_iterator generatorInfo_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< generatorInfo_type, char > generatorInfo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const generatorInfo_sequence&
  generatorInfo () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  generatorInfo_sequence&
  generatorInfo ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  generatorInfo (const generatorInfo_sequence& s);

  //@}

  /**
   * @name thermostat
   *
   * @brief Accessor and modifier functions for the %thermostat
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::thermostat_info_t thermostat_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< thermostat_type > thermostat_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< thermostat_type, char > thermostat_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const thermostat_optional&
  thermostat () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  thermostat_optional&
  thermostat ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  thermostat (const thermostat_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  thermostat (const thermostat_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  thermostat (::std::unique_ptr< thermostat_type > p);

  //@}

  /**
   * @name checkpointInput
   *
   * @brief Accessor and modifier functions for the %checkpointInput
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string checkpointInput_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< checkpointInput_type > checkpointInput_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< checkpointInput_type, char > checkpointInput_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const checkpointInput_optional&
  checkpointInput () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  checkpointInput_optional&
  checkpointInput ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  checkpointInput (const checkpointInput_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  checkpointInput (const checkpointInput_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  checkpointInput (::std::unique_ptr< checkpointInput_type > p);

  //@}

  /**
   * @name checkpointOutput
   *
   * @brief Accessor and modifier functions for the %checkpointOutput
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string checkpointOutput_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< checkpointOutput_type > checkpointOutput_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< checkpointOutput_type, char > checkpointOutput_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const checkpointOutput_optional&
  checkpointOutput () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  checkpointOutput_optional&
  checkpointOutput ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  checkpointOutput (const checkpointOutput_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  checkpointOutput (const checkpointOutput_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  checkpointOutput (::std::unique_ptr< checkpointOutput_type > p);

  //@}

  /**
   * @name statistics
   *
   * @brief Accessor and modifier functions for the %statistics
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::statistics_t statistics_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< statistics_type > statistics_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< statistics_type, char > statistics_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const statistics_optional&
  statistics () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  statistics_optional&
  statistics ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  statistics (const statistics_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  statistics (const statistics_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  statistics (::std::unique_ptr< statistics_type > p);

  //@}

  /**
   * @name t_end
   *
   * @brief Accessor and modifier functions for the %t_end
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::decimal t_end_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< t_end_type, char, ::xsd::cxx::tree::schema_type::decimal > t_end_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const t_end_type&
  t_end () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  t_end_type&
  t_end ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  t_end (const t_end_type& x);

  //@}

  /**
   * @name delta_t
   *
   * @brief Accessor and modifier functions for the %delta_t
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::decimal delta_t_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< delta_t_type, char, ::xsd::cxx::tree::schema_type::decimal > delta_t_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const delta_t_type&
  delta_t () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  delta_t_type&
  delta_t ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  delta_t (const delta_t_type& x);

  //@}

  /**
   * @name writeFrequency
   *
   * @brief Accessor and modifier functions for the %writeFrequency
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::int_ writeFrequency_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< writeFrequency_type, char > writeFrequency_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const writeFrequency_type&
  writeFrequency () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  writeFrequency_type&
  writeFrequency ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  writeFrequency (const writeFrequency_type& x);

  //@}

  /**
   * @name outputWriter
   *
   * @brief Accessor and modifier functions for the %outputWriter
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::outputwriter_t outputWriter_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< outputWriter_type, char > outputWriter_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const outputWriter_type&
  outputWriter () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  outputWriter_type&
  outputWriter ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  outputWriter (const outputWriter_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  outputWriter (::std::unique_ptr< outputWriter_type > p);

  //@}

  /**
   * @name random
   *
   * @brief Accessor and modifier functions for the %random
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::boolean random_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< random_type > random_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< random_type, char > random_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const random_optional&
  random () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  random_optional&
  random ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  random (const random_type& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  random (const random_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  simulation_t (const container_type&,
                const calculator_type&,
                const outputFile_type&,
                const t_end_type&,
                const delta_t_type&,
                const writeFrequency_type&,
                const outputWriter_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  simulation_t (::std::unique_ptr< container_type >,
                ::std::unique_ptr< calculator_type >,
                const outputFile_type&,
                const t_end_type&,
                const delta_t_type&,
                const writeFrequency_type&,
                const outputWriter_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  simulation_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  simulation_t (const simulation_t& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual simulation_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  simulation_t&
  operator= (const simulation_t& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~simulation_t ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< container_type > container_;
  ::xsd::cxx::tree::one< calculator_type > calculator_;
  inputFile_sequence inputFile_;
  generatorFile_sequence generatorFile_;
  ::xsd::cxx::tree::one< outputFile_type > outputFile_;
  generatorInfo_sequence generatorInfo_;
  thermostat_optional thermostat_;
  checkpointInput_optional checkpointInput_;
  checkpointOutput_optional checkpointOutput_;
  statistics_optional statistics_;
  ::xsd::cxx::tree::one< t_end_type > t_end_;
  ::xsd::cxx::tree::one< delta_t_type > delta_t_;
  ::xsd::cxx::tree::one< writeFrequency_type > writeFrequency_;
  ::xsd::cxx::tree::one< outputWriter_type > outputWriter_;
  random_optional random_;

  //@endcond
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

/**
 * @name Parsing functions for the %simulation document root.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::simulation_t >
simulation (const ::std::string& uri,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation_t >
simulation (const ::std::string& uri,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation_t >
simulation (const ::std::string& uri,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::simulation_t >
simulation (::std::istream& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation_t >
simulation (::std::istream& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation_t >
simulation (::std::istream& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::simulation_t >
simulation (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation_t >
simulation (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation_t >
simulation (::std::istream& is,
            const ::std::string& id,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::simulation_t >
simulation (::xercesc::InputSource& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation_t >
simulation (::xercesc::InputSource& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation_t >
simulation (::xercesc::InputSource& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 */
::std::unique_ptr< ::simulation_t >
simulation (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::unique_ptr< ::simulation_t >
simulation (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

//@}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const geometric_t&);

void
operator<< (::xercesc::DOMAttr&, const geometric_t&);

void
operator<< (::xml_schema::list_stream&,
            const geometric_t&);

void
operator<< (::xercesc::DOMElement&, const border_single_t&);

void
operator<< (::xercesc::DOMAttr&, const border_single_t&);

void
operator<< (::xml_schema::list_stream&,
            const border_single_t&);

void
operator<< (::xercesc::DOMElement&, const border_t&);

void
operator<< (::xercesc::DOMElement&, const behaviour_t&);

void
operator<< (::xercesc::DOMAttr&, const behaviour_t&);

void
operator<< (::xml_schema::list_stream&,
            const behaviour_t&);

void
operator<< (::xercesc::DOMElement&, const generator_info_t&);

void
operator<< (::xercesc::DOMElement&, const containertype_t&);

void
operator<< (::xercesc::DOMAttr&, const containertype_t&);

void
operator<< (::xml_schema::list_stream&,
            const containertype_t&);

void
operator<< (::xercesc::DOMElement&, const calculatortype_t&);

void
operator<< (::xercesc::DOMAttr&, const calculatortype_t&);

void
operator<< (::xml_schema::list_stream&,
            const calculatortype_t&);

void
operator<< (::xercesc::DOMElement&, const containerinfo_t&);

void
operator<< (::xercesc::DOMElement&, const calculationInfo_t&);

void
operator<< (::xercesc::DOMElement&, const outputwriter_t&);

void
operator<< (::xercesc::DOMAttr&, const outputwriter_t&);

void
operator<< (::xml_schema::list_stream&,
            const outputwriter_t&);

void
operator<< (::xercesc::DOMElement&, const thermostat_info_t&);

void
operator<< (::xercesc::DOMElement&, const statistics_type_t&);

void
operator<< (::xercesc::DOMAttr&, const statistics_type_t&);

void
operator<< (::xml_schema::list_stream&,
            const statistics_type_t&);

void
operator<< (::xercesc::DOMElement&, const statistics_t&);

void
operator<< (::xercesc::DOMElement&, const array_int_3&);

void
operator<< (::xercesc::DOMElement&, const array_float_3&);

void
operator<< (::xercesc::DOMElement&, const special_particle_t&);

void
operator<< (::xercesc::DOMElement&, const simulation_t&);

/**
 * @name Serialization functions for the %simulation document root.
 */
//@{

/**
 * @brief Serialize to a standard output stream.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
simulation (::std::ostream& os,
            const ::simulation_t& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with an error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
simulation (::std::ostream& os,
            const ::simulation_t& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with a Xerces-C++ DOM
 * error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
simulation (::std::ostream& os,
            const ::simulation_t& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
simulation (::xercesc::XMLFormatTarget& ft,
            const ::simulation_t& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with an error
 * handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
simulation (::xercesc::XMLFormatTarget& ft,
            const ::simulation_t& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with a
 * Xerces-C++ DOM error handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
simulation (::xercesc::XMLFormatTarget& ft,
            const ::simulation_t& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to an existing Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param x An object model to serialize.
 * @param f Serialization flags.
 *
 * Note that it is your responsibility to create the DOM document
 * with the correct root element as well as set the necessary
 * namespace mapping attributes.
 */
void
simulation (::xercesc::DOMDocument& d,
            const ::simulation_t& x,
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a new Xerces-C++ DOM document.
 *
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param f Serialization flags.
 * @return A pointer to the new Xerces-C++ DOM document.
 */
::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
simulation (const ::simulation_t& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            ::xml_schema::flags f = 0);

//@}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // SIMULATION_H
