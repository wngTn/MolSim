// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from simulation.xsd.
 */

#ifndef SIMULATION_H
#define SIMULATION_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema {
// anyType and anySimpleType.
//

/**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::type type;

/**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::simple_type<char, type> simple_type;

/**
   * @brief Alias for the anyType type.
   */
typedef ::xsd::cxx::tree::type container;


// 8-bit
//

/**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
typedef signed char byte;

/**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
typedef unsigned char unsigned_byte;


// 16-bit
//

/**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
typedef short short_;

/**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
typedef unsigned short unsigned_short;


// 32-bit
//

/**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
typedef int int_;

/**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
typedef unsigned int unsigned_int;


// 64-bit
//

/**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
typedef long long long_;

/**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
typedef unsigned long long unsigned_long;


// Supposed to be arbitrary-length integral types.
//

/**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
typedef long long integer;

/**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
typedef long long non_positive_integer;

/**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
typedef unsigned long long non_negative_integer;

/**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
typedef unsigned long long positive_integer;

/**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
typedef long long negative_integer;


// Boolean.
//

/**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
typedef bool boolean;


// Floating-point types.
//

/**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
typedef float float_;

/**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
typedef double double_;

/**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
typedef double decimal;


// String types.
//

/**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::string<char, simple_type> string;

/**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::normalized_string<char, string> normalized_string;

/**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::token<char, normalized_string> token;

/**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::name<char, token> name;

/**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::nmtoken<char, token> nmtoken;

/**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::nmtokens<char, simple_type, nmtoken> nmtokens;

/**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::ncname<char, name> ncname;

/**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::language<char, token> language;


// ID/IDREF.
//

/**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::id<char, ncname> id;

/**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::idref<char, ncname, type> idref;

/**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::idrefs<char, simple_type, idref> idrefs;


// URI.
//

/**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::uri<char, simple_type> uri;


// Qualified name.
//

/**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::qname<char, simple_type, uri, ncname> qname;


// Binary.
//

/**
   * @brief Binary buffer type.
   */
typedef ::xsd::cxx::tree::buffer<char> buffer;

/**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::base64_binary<char, simple_type> base64_binary;

/**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::hex_binary<char, simple_type> hex_binary;


// Date/time.
//

/**
   * @brief Time zone type.
   */
typedef ::xsd::cxx::tree::time_zone time_zone;

/**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::date<char, simple_type> date;

/**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::date_time<char, simple_type> date_time;

/**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::duration<char, simple_type> duration;

/**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::gday<char, simple_type> gday;

/**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::gmonth<char, simple_type> gmonth;

/**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::gmonth_day<char, simple_type> gmonth_day;

/**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::gyear<char, simple_type> gyear;

/**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::gyear_month<char, simple_type> gyear_month;

/**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::time<char, simple_type> time;


// Entity.
//

/**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::entity<char, ncname> entity;

/**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
typedef ::xsd::cxx::tree::entities<char, simple_type, entity> entities;

/**
   * @brief Content order sequence entry.
   */
typedef ::xsd::cxx::tree::content_order content_order;
// Namespace information and list stream. Used in
// serialization functions.
//
/**
   * @brief Namespace serialization information.
   */
typedef ::xsd::cxx::xml::dom::namespace_info<char> namespace_info;

/**
   * @brief Namespace serialization information map.
   */
typedef ::xsd::cxx::xml::dom::namespace_infomap<char> namespace_infomap;

/**
   * @brief List serialization stream.
   */
typedef ::xsd::cxx::tree::list_stream<char> list_stream;

/**
   * @brief Serialization wrapper for the %double type.
   */
typedef ::xsd::cxx::tree::as_double<double_> as_double;

/**
   * @brief Serialization wrapper for the %decimal type.
   */
typedef ::xsd::cxx::tree::as_decimal<decimal> as_decimal;

/**
   * @brief Simple type facet.
   */
typedef ::xsd::cxx::tree::facet facet;

// Flags and properties.
//

/**
   * @brief Parsing and serialization flags.
   */
typedef ::xsd::cxx::tree::flags flags;

/**
   * @brief Parsing properties.
   */
typedef ::xsd::cxx::tree::properties<char> properties;

// Parsing/serialization diagnostics.
//

/**
   * @brief Error severity.
   */
typedef ::xsd::cxx::tree::severity severity;

/**
   * @brief Error condition.
   */
typedef ::xsd::cxx::tree::error<char> error;

/**
   * @brief List of %error conditions.
   */
typedef ::xsd::cxx::tree::diagnostics<char> diagnostics;

// Exceptions.
//

/**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
typedef ::xsd::cxx::tree::exception<char> exception;

/**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
typedef ::xsd::cxx::tree::bounds<char> bounds;

/**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
typedef ::xsd::cxx::tree::duplicate_id<char> duplicate_id;

/**
   * @brief Exception indicating a parsing failure.
   */
typedef ::xsd::cxx::tree::parsing<char> parsing;

/**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
typedef ::xsd::cxx::tree::expected_element<char> expected_element;

/**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
typedef ::xsd::cxx::tree::unexpected_element<char> unexpected_element;

/**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
typedef ::xsd::cxx::tree::expected_attribute<char> expected_attribute;

/**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
typedef ::xsd::cxx::tree::unexpected_enumerator<char> unexpected_enumerator;

/**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
typedef ::xsd::cxx::tree::expected_text_content<char> expected_text_content;

/**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
typedef ::xsd::cxx::tree::no_prefix_mapping<char> no_prefix_mapping;

/**
   * @brief Exception indicating a serialization failure.
   */
typedef ::xsd::cxx::tree::serialization<char> serialization;

/**
   * @brief Error handler callback interface.
   */
typedef ::xsd::cxx::xml::error_handler<char> error_handler;

/**
   * @brief DOM interaction.
   */
namespace dom {
/**
     * @brief Automatic pointer for DOMDocument.
     */
using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA

/**
     * @brief DOM user data key for back pointers to tree nodes.
     */
const XMLCh *const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;

#endif
}
}

// Forward declarations.
//
class parallel_t;

class geometric_t;

class border_single_t;

class border_t;

class behaviour_t;

class generator_info_t;

class containertype_t;

class calculatortype_t;

class containerinfo_t;

class calculationInfo_t;

class outputwriter_t;

class thermostat_info_t;

class statistics_type_t;

class statistics_t;

class array_int_3;

class array_float_3;

class special_particle_t;

class simulation_t;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

/**
 * @brief Enumeration class corresponding to the %parallel_t
 * schema type.
 */
class parallel_t : public ::xml_schema::string {
public:

	/**
   * @brief Underlying enum type.
   */
	enum value {
		primitiveX,
		primitiveY,
		primitiveZ,
		subdomain,
		none
	};

	/**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
	parallel_t(value v);

	/**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
	parallel_t(const char *v);

	/**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
	parallel_t(const ::std::string &v);

	/**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
	parallel_t(const ::xml_schema::string &v);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	parallel_t(const ::xercesc::DOMElement &e,
	           ::xml_schema::flags f = 0,
	           ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	parallel_t(const ::xercesc::DOMAttr &a,
	           ::xml_schema::flags f = 0,
	           ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	parallel_t(const ::std::string &s,
	           const ::xercesc::DOMElement *e,
	           ::xml_schema::flags f = 0,
	           ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	parallel_t(const parallel_t &x,
	           ::xml_schema::flags f = 0,
	           ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual parallel_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
	parallel_t &
	operator=(value v);

	/**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
	virtual
	operator value() const {
		return _xsd_parallel_t_convert();
	}

	//@cond

protected:
	value
	_xsd_parallel_t_convert() const;

public:
	static const char *const _xsd_parallel_t_literals_[5];
	static const value _xsd_parallel_t_indexes_[5];

	//@endcond
};

/**
 * @brief Enumeration class corresponding to the %geometric_t
 * schema type.
 */
class geometric_t : public ::xml_schema::string {
public:

	/**
   * @brief Underlying enum type.
   */
	enum value {
		cuboid,
		sphere
	};

	/**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
	geometric_t(value v);

	/**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
	geometric_t(const char *v);

	/**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
	geometric_t(const ::std::string &v);

	/**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
	geometric_t(const ::xml_schema::string &v);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	geometric_t(const ::xercesc::DOMElement &e,
	            ::xml_schema::flags f = 0,
	            ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	geometric_t(const ::xercesc::DOMAttr &a,
	            ::xml_schema::flags f = 0,
	            ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	geometric_t(const ::std::string &s,
	            const ::xercesc::DOMElement *e,
	            ::xml_schema::flags f = 0,
	            ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	geometric_t(const geometric_t &x,
	            ::xml_schema::flags f = 0,
	            ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual geometric_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
	geometric_t &
	operator=(value v);

	/**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
	virtual
	operator value() const {
		return _xsd_geometric_t_convert();
	}

	//@cond

protected:
	value
	_xsd_geometric_t_convert() const;

public:
	static const char *const _xsd_geometric_t_literals_[2];
	static const value _xsd_geometric_t_indexes_[2];

	//@endcond
};

/**
 * @brief Enumeration class corresponding to the %border_single_t
 * schema type.
 */
class border_single_t : public ::xml_schema::string {
public:

	/**
   * @brief Underlying enum type.
   */
	enum value {
		periodic,
		reflective,
		outflow
	};

	/**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
	border_single_t(value v);

	/**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
	border_single_t(const char *v);

	/**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
	border_single_t(const ::std::string &v);

	/**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
	border_single_t(const ::xml_schema::string &v);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	border_single_t(const ::xercesc::DOMElement &e,
	                ::xml_schema::flags f = 0,
	                ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	border_single_t(const ::xercesc::DOMAttr &a,
	                ::xml_schema::flags f = 0,
	                ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	border_single_t(const ::std::string &s,
	                const ::xercesc::DOMElement *e,
	                ::xml_schema::flags f = 0,
	                ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	border_single_t(const border_single_t &x,
	                ::xml_schema::flags f = 0,
	                ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual border_single_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
	border_single_t &
	operator=(value v);

	/**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
	virtual
	operator value() const {
		return _xsd_border_single_t_convert();
	}

	//@cond

protected:
	value
	_xsd_border_single_t_convert() const;

public:
	static const char *const _xsd_border_single_t_literals_[3];
	static const value _xsd_border_single_t_indexes_[3];

	//@endcond
};

/**
 * @brief Class corresponding to the %border_t schema type.
 *
 * @nosubgrouping
 */
class border_t : public ::xml_schema::type {
public:
	/**
   * @name left
   *
   * @brief Accessor and modifier functions for the %left
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::border_single_t left_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<left_type, char> left_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const left_type &
	left() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	left_type &
	left();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	left(const left_type &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	left(::std::unique_ptr<left_type> p);

	//@}

	/**
   * @name right
   *
   * @brief Accessor and modifier functions for the %right
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::border_single_t right_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<right_type, char> right_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const right_type &
	right() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	right_type &
	right();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	right(const right_type &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	right(::std::unique_ptr<right_type> p);

	//@}

	/**
   * @name upper
   *
   * @brief Accessor and modifier functions for the %upper
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::border_single_t upper_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<upper_type, char> upper_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const upper_type &
	upper() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	upper_type &
	upper();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	upper(const upper_type &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	upper(::std::unique_ptr<upper_type> p);

	//@}

	/**
   * @name lower
   *
   * @brief Accessor and modifier functions for the %lower
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::border_single_t lower_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<lower_type, char> lower_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const lower_type &
	lower() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	lower_type &
	lower();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	lower(const lower_type &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	lower(::std::unique_ptr<lower_type> p);

	//@}

	/**
   * @name front
   *
   * @brief Accessor and modifier functions for the %front
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::border_single_t front_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<front_type> front_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<front_type, char> front_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const front_optional &
	front() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	front_optional &
	front();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	front(const front_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	front(const front_optional &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
	void
	front(::std::unique_ptr<front_type> p);

	//@}

	/**
   * @name back
   *
   * @brief Accessor and modifier functions for the %back
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::border_single_t back_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<back_type> back_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<back_type, char> back_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const back_optional &
	back() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	back_optional &
	back();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	back(const back_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	back(const back_optional &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
	void
	back(::std::unique_ptr<back_type> p);

	//@}

	/**
   * @name Constructors
   */
	//@{

	/**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
	border_t(const left_type &,
	         const right_type &,
	         const upper_type &,
	         const lower_type &);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	border_t(const ::xercesc::DOMElement &e,
	         ::xml_schema::flags f = 0,
	         ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	border_t(const border_t &x,
	         ::xml_schema::flags f = 0,
	         ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual border_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	border_t &
	operator=(const border_t &x);

	//@}

	/**
   * @brief Destructor.
   */
	virtual
	~border_t();

	// Implementation.
	//

	//@cond

protected:
	void
	parse(::xsd::cxx::xml::dom::parser<char> &,
	      ::xml_schema::flags);

protected:
	::xsd::cxx::tree::one<left_type> left_;
	::xsd::cxx::tree::one<right_type> right_;
	::xsd::cxx::tree::one<upper_type> upper_;
	::xsd::cxx::tree::one<lower_type> lower_;
	front_optional front_;
	back_optional back_;

	//@endcond
};

/**
 * @brief Enumeration class corresponding to the %behaviour_t
 * schema type.
 */
class behaviour_t : public ::xml_schema::string {
public:

	/**
   * @brief Underlying enum type.
   */
	enum value {
		normal,
		membrane,
		immovable
	};

	/**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
	behaviour_t(value v);

	/**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
	behaviour_t(const char *v);

	/**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
	behaviour_t(const ::std::string &v);

	/**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
	behaviour_t(const ::xml_schema::string &v);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	behaviour_t(const ::xercesc::DOMElement &e,
	            ::xml_schema::flags f = 0,
	            ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	behaviour_t(const ::xercesc::DOMAttr &a,
	            ::xml_schema::flags f = 0,
	            ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	behaviour_t(const ::std::string &s,
	            const ::xercesc::DOMElement *e,
	            ::xml_schema::flags f = 0,
	            ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	behaviour_t(const behaviour_t &x,
	            ::xml_schema::flags f = 0,
	            ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual behaviour_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
	behaviour_t &
	operator=(value v);

	/**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
	virtual
	operator value() const {
		return _xsd_behaviour_t_convert();
	}

	//@cond

protected:
	value
	_xsd_behaviour_t_convert() const;

public:
	static const char *const _xsd_behaviour_t_literals_[3];
	static const value _xsd_behaviour_t_indexes_[3];

	//@endcond
};

/**
 * @brief Class corresponding to the %generator_info_t schema type.
 *
 * @nosubgrouping
 */
class generator_info_t : public ::xml_schema::type {
public:
	/**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal x_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<x_type, char, ::xsd::cxx::tree::schema_type::decimal> x_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const x_type &
	x() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	x_type &
	x();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	x(const x_type &x);

	//@}

	/**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal y_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<y_type, char, ::xsd::cxx::tree::schema_type::decimal> y_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const y_type &
	y() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	y_type &
	y();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	y(const y_type &x);

	//@}

	/**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal z_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<z_type, char, ::xsd::cxx::tree::schema_type::decimal> z_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const z_type &
	z() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	z_type &
	z();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	z(const z_type &x);

	//@}

	/**
   * @name v1
   *
   * @brief Accessor and modifier functions for the %v1
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal v1_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<v1_type, char, ::xsd::cxx::tree::schema_type::decimal> v1_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const v1_type &
	v1() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	v1_type &
	v1();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	v1(const v1_type &x);

	//@}

	/**
   * @name v2
   *
   * @brief Accessor and modifier functions for the %v2
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal v2_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<v2_type, char, ::xsd::cxx::tree::schema_type::decimal> v2_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const v2_type &
	v2() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	v2_type &
	v2();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	v2(const v2_type &x);

	//@}

	/**
   * @name v3
   *
   * @brief Accessor and modifier functions for the %v3
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal v3_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<v3_type, char, ::xsd::cxx::tree::schema_type::decimal> v3_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const v3_type &
	v3() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	v3_type &
	v3();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	v3(const v3_type &x);

	//@}

	/**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal mass_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<mass_type, char, ::xsd::cxx::tree::schema_type::decimal> mass_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const mass_type &
	mass() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	mass_type &
	mass();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	mass(const mass_type &x);

	//@}

	/**
   * @name epsilon
   *
   * @brief Accessor and modifier functions for the %epsilon
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal epsilon_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<epsilon_type, char, ::xsd::cxx::tree::schema_type::decimal> epsilon_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const epsilon_type &
	epsilon() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	epsilon_type &
	epsilon();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	epsilon(const epsilon_type &x);

	//@}

	/**
   * @name sigma
   *
   * @brief Accessor and modifier functions for the %sigma
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal sigma_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<sigma_type, char, ::xsd::cxx::tree::schema_type::decimal> sigma_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const sigma_type &
	sigma() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	sigma_type &
	sigma();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	sigma(const sigma_type &x);

	//@}

	/**
   * @name distance
   *
   * @brief Accessor and modifier functions for the %distance
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal distance_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<distance_type, char, ::xsd::cxx::tree::schema_type::decimal> distance_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const distance_type &
	distance() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	distance_type &
	distance();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	distance(const distance_type &x);

	//@}

	/**
   * @name brownianFactor
   *
   * @brief Accessor and modifier functions for the %brownianFactor
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal brownianFactor_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<brownianFactor_type, char, ::xsd::cxx::tree::schema_type::decimal>
		brownianFactor_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const brownianFactor_type &
	brownianFactor() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	brownianFactor_type &
	brownianFactor();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	brownianFactor(const brownianFactor_type &x);

	//@}

	/**
   * @name dim
   *
   * @brief Accessor and modifier functions for the %dim
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::int_ dim_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<dim_type, char> dim_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const dim_type &
	dim() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	dim_type &
	dim();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	dim(const dim_type &x);

	//@}

	/**
   * @name n1
   *
   * @brief Accessor and modifier functions for the %n1
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::int_ n1_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<n1_type> n1_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<n1_type, char> n1_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const n1_optional &
	n1() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	n1_optional &
	n1();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	n1(const n1_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	n1(const n1_optional &x);

	//@}

	/**
   * @name n2
   *
   * @brief Accessor and modifier functions for the %n2
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::int_ n2_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<n2_type> n2_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<n2_type, char> n2_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const n2_optional &
	n2() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	n2_optional &
	n2();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	n2(const n2_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	n2(const n2_optional &x);

	//@}

	/**
   * @name n3
   *
   * @brief Accessor and modifier functions for the %n3
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::int_ n3_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<n3_type> n3_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<n3_type, char> n3_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const n3_optional &
	n3() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	n3_optional &
	n3();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	n3(const n3_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	n3(const n3_optional &x);

	//@}

	/**
   * @name radius
   *
   * @brief Accessor and modifier functions for the %radius
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::int_ radius_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<radius_type> radius_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<radius_type, char> radius_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const radius_optional &
	radius() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	radius_optional &
	radius();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	radius(const radius_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	radius(const radius_optional &x);

	//@}

	/**
   * @name special_particle
   *
   * @brief Accessor and modifier functions for the %special_particle
   * sequence element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::special_particle_t special_particle_type;

	/**
   * @brief Element sequence container type.
   */
	typedef ::xsd::cxx::tree::sequence<special_particle_type> special_particle_sequence;

	/**
   * @brief Element iterator type.
   */
	typedef special_particle_sequence::iterator special_particle_iterator;

	/**
   * @brief Element constant iterator type.
   */
	typedef special_particle_sequence::const_iterator special_particle_const_iterator;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<special_particle_type, char> special_particle_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
	const special_particle_sequence &
	special_particle() const;

	/**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
	special_particle_sequence &
	special_particle();

	/**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
	void
	special_particle(const special_particle_sequence &s);

	//@}

	/**
   * @name baseForce
   *
   * @brief Accessor and modifier functions for the %baseForce
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::array_float_3 baseForce_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<baseForce_type> baseForce_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<baseForce_type, char> baseForce_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const baseForce_optional &
	baseForce() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	baseForce_optional &
	baseForce();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	baseForce(const baseForce_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	baseForce(const baseForce_optional &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
	void
	baseForce(::std::unique_ptr<baseForce_type> p);

	//@}

	/**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::geometric_t type_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const type_type &
	type() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	type_type &
	type();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	type(const type_type &x);

	/**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	type(::std::unique_ptr<type_type> p);

	//@}

	/**
   * @name behaviour
   *
   * @brief Accessor and modifier functions for the %behaviour
   * optional attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::behaviour_t behaviour_type;

	/**
   * @brief Attribute optional container type.
   */
	typedef ::xsd::cxx::tree::optional<behaviour_type> behaviour_optional;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<behaviour_type, char> behaviour_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const behaviour_optional &
	behaviour() const;

	/**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
	behaviour_optional &
	behaviour();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	behaviour(const behaviour_type &x);

	/**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
	void
	behaviour(const behaviour_optional &x);

	/**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
	void
	behaviour(::std::unique_ptr<behaviour_type> p);

	//@}

	/**
   * @name Constructors
   */
	//@{

	/**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
	generator_info_t(const x_type &,
	                 const y_type &,
	                 const z_type &,
	                 const v1_type &,
	                 const v2_type &,
	                 const v3_type &,
	                 const mass_type &,
	                 const epsilon_type &,
	                 const sigma_type &,
	                 const distance_type &,
	                 const brownianFactor_type &,
	                 const dim_type &,
	                 const type_type &);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	generator_info_t(const ::xercesc::DOMElement &e,
	                 ::xml_schema::flags f = 0,
	                 ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	generator_info_t(const generator_info_t &x,
	                 ::xml_schema::flags f = 0,
	                 ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual generator_info_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	generator_info_t &
	operator=(const generator_info_t &x);

	//@}

	/**
   * @brief Destructor.
   */
	virtual
	~generator_info_t();

	// Implementation.
	//

	//@cond

protected:
	void
	parse(::xsd::cxx::xml::dom::parser<char> &,
	      ::xml_schema::flags);

protected:
	::xsd::cxx::tree::one<x_type> x_;
	::xsd::cxx::tree::one<y_type> y_;
	::xsd::cxx::tree::one<z_type> z_;
	::xsd::cxx::tree::one<v1_type> v1_;
	::xsd::cxx::tree::one<v2_type> v2_;
	::xsd::cxx::tree::one<v3_type> v3_;
	::xsd::cxx::tree::one<mass_type> mass_;
	::xsd::cxx::tree::one<epsilon_type> epsilon_;
	::xsd::cxx::tree::one<sigma_type> sigma_;
	::xsd::cxx::tree::one<distance_type> distance_;
	::xsd::cxx::tree::one<brownianFactor_type> brownianFactor_;
	::xsd::cxx::tree::one<dim_type> dim_;
	n1_optional n1_;
	n2_optional n2_;
	n3_optional n3_;
	radius_optional radius_;
	special_particle_sequence special_particle_;
	baseForce_optional baseForce_;
	::xsd::cxx::tree::one<type_type> type_;
	behaviour_optional behaviour_;

	//@endcond
};

/**
 * @brief Enumeration class corresponding to the %containertype_t
 * schema type.
 */
class containertype_t : public ::xml_schema::string {
public:

	/**
   * @brief Underlying enum type.
   */
	enum value {
		linkedcell,
		directsum
	};

	/**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
	containertype_t(value v);

	/**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
	containertype_t(const char *v);

	/**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
	containertype_t(const ::std::string &v);

	/**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
	containertype_t(const ::xml_schema::string &v);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	containertype_t(const ::xercesc::DOMElement &e,
	                ::xml_schema::flags f = 0,
	                ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	containertype_t(const ::xercesc::DOMAttr &a,
	                ::xml_schema::flags f = 0,
	                ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	containertype_t(const ::std::string &s,
	                const ::xercesc::DOMElement *e,
	                ::xml_schema::flags f = 0,
	                ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	containertype_t(const containertype_t &x,
	                ::xml_schema::flags f = 0,
	                ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual containertype_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
	containertype_t &
	operator=(value v);

	/**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
	virtual
	operator value() const {
		return _xsd_containertype_t_convert();
	}

	//@cond

protected:
	value
	_xsd_containertype_t_convert() const;

public:
	static const char *const _xsd_containertype_t_literals_[2];
	static const value _xsd_containertype_t_indexes_[2];

	//@endcond
};

/**
 * @brief Enumeration class corresponding to the %calculatortype_t
 * schema type.
 */
class calculatortype_t : public ::xml_schema::string {
public:

	/**
   * @brief Underlying enum type.
   */
	enum value {
		lennardjones,
		smoothed_lennardjones,
		gravitation
	};

	/**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
	calculatortype_t(value v);

	/**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
	calculatortype_t(const char *v);

	/**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
	calculatortype_t(const ::std::string &v);

	/**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
	calculatortype_t(const ::xml_schema::string &v);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	calculatortype_t(const ::xercesc::DOMElement &e,
	                 ::xml_schema::flags f = 0,
	                 ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	calculatortype_t(const ::xercesc::DOMAttr &a,
	                 ::xml_schema::flags f = 0,
	                 ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	calculatortype_t(const ::std::string &s,
	                 const ::xercesc::DOMElement *e,
	                 ::xml_schema::flags f = 0,
	                 ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	calculatortype_t(const calculatortype_t &x,
	                 ::xml_schema::flags f = 0,
	                 ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual calculatortype_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
	calculatortype_t &
	operator=(value v);

	/**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
	virtual
	operator value() const {
		return _xsd_calculatortype_t_convert();
	}

	//@cond

protected:
	value
	_xsd_calculatortype_t_convert() const;

public:
	static const char *const _xsd_calculatortype_t_literals_[3];
	static const value _xsd_calculatortype_t_indexes_[3];

	//@endcond
};

/**
 * @brief Class corresponding to the %containerinfo_t schema type.
 *
 * @nosubgrouping
 */
class containerinfo_t : public ::xml_schema::type {
public:
	/**
   * @name rCut
   *
   * @brief Accessor and modifier functions for the %rCut
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal rCut_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<rCut_type> rCut_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<rCut_type, char, ::xsd::cxx::tree::schema_type::decimal> rCut_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const rCut_optional &
	rCut() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	rCut_optional &
	rCut();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	rCut(const rCut_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	rCut(const rCut_optional &x);

	//@}

	/**
   * @name domainSizeX
   *
   * @brief Accessor and modifier functions for the %domainSizeX
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal domainSizeX_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<domainSizeX_type> domainSizeX_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<domainSizeX_type, char, ::xsd::cxx::tree::schema_type::decimal> domainSizeX_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const domainSizeX_optional &
	domainSizeX() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	domainSizeX_optional &
	domainSizeX();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	domainSizeX(const domainSizeX_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	domainSizeX(const domainSizeX_optional &x);

	//@}

	/**
   * @name domainSizeY
   *
   * @brief Accessor and modifier functions for the %domainSizeY
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal domainSizeY_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<domainSizeY_type> domainSizeY_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<domainSizeY_type, char, ::xsd::cxx::tree::schema_type::decimal> domainSizeY_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const domainSizeY_optional &
	domainSizeY() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	domainSizeY_optional &
	domainSizeY();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	domainSizeY(const domainSizeY_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	domainSizeY(const domainSizeY_optional &x);

	//@}

	/**
   * @name domainSizeZ
   *
   * @brief Accessor and modifier functions for the %domainSizeZ
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal domainSizeZ_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<domainSizeZ_type> domainSizeZ_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<domainSizeZ_type, char, ::xsd::cxx::tree::schema_type::decimal> domainSizeZ_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const domainSizeZ_optional &
	domainSizeZ() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	domainSizeZ_optional &
	domainSizeZ();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	domainSizeZ(const domainSizeZ_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	domainSizeZ(const domainSizeZ_optional &x);

	//@}

	/**
   * @name borderType
   *
   * @brief Accessor and modifier functions for the %borderType
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::border_t borderType_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<borderType_type> borderType_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<borderType_type, char> borderType_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const borderType_optional &
	borderType() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	borderType_optional &
	borderType();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	borderType(const borderType_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	borderType(const borderType_optional &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
	void
	borderType(::std::unique_ptr<borderType_type> p);

	//@}

	/**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::containertype_t type_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const type_type &
	type() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	type_type &
	type();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	type(const type_type &x);

	/**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	type(::std::unique_ptr<type_type> p);

	//@}

	/**
   * @name Constructors
   */
	//@{

	/**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
	containerinfo_t(const type_type &);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	containerinfo_t(const ::xercesc::DOMElement &e,
	                ::xml_schema::flags f = 0,
	                ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	containerinfo_t(const containerinfo_t &x,
	                ::xml_schema::flags f = 0,
	                ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual containerinfo_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	containerinfo_t &
	operator=(const containerinfo_t &x);

	//@}

	/**
   * @brief Destructor.
   */
	virtual
	~containerinfo_t();

	// Implementation.
	//

	//@cond

protected:
	void
	parse(::xsd::cxx::xml::dom::parser<char> &,
	      ::xml_schema::flags);

protected:
	rCut_optional rCut_;
	domainSizeX_optional domainSizeX_;
	domainSizeY_optional domainSizeY_;
	domainSizeZ_optional domainSizeZ_;
	borderType_optional borderType_;
	::xsd::cxx::tree::one<type_type> type_;

	//@endcond
};

/**
 * @brief Class corresponding to the %calculationInfo_t schema type.
 *
 * @nosubgrouping
 */
class calculationInfo_t : public ::xml_schema::type {
public:
	/**
   * @name epsilon
   *
   * @brief Accessor and modifier functions for the %epsilon
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal epsilon_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<epsilon_type> epsilon_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<epsilon_type, char, ::xsd::cxx::tree::schema_type::decimal> epsilon_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const epsilon_optional &
	epsilon() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	epsilon_optional &
	epsilon();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	epsilon(const epsilon_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	epsilon(const epsilon_optional &x);

	//@}

	/**
   * @name sigma
   *
   * @brief Accessor and modifier functions for the %sigma
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal sigma_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<sigma_type> sigma_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<sigma_type, char, ::xsd::cxx::tree::schema_type::decimal> sigma_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const sigma_optional &
	sigma() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	sigma_optional &
	sigma();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	sigma(const sigma_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	sigma(const sigma_optional &x);

	//@}

	/**
   * @name gravityFactor
   *
   * @brief Accessor and modifier functions for the %gravityFactor
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::array_float_3 gravityFactor_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<gravityFactor_type> gravityFactor_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<gravityFactor_type, char> gravityFactor_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const gravityFactor_optional &
	gravityFactor() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	gravityFactor_optional &
	gravityFactor();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	gravityFactor(const gravityFactor_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	gravityFactor(const gravityFactor_optional &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
	void
	gravityFactor(::std::unique_ptr<gravityFactor_type> p);

	//@}

	/**
   * @name brownianMotion
   *
   * @brief Accessor and modifier functions for the %brownianMotion
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal brownianMotion_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<brownianMotion_type> brownianMotion_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<brownianMotion_type, char, ::xsd::cxx::tree::schema_type::decimal>
		brownianMotion_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const brownianMotion_optional &
	brownianMotion() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	brownianMotion_optional &
	brownianMotion();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	brownianMotion(const brownianMotion_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	brownianMotion(const brownianMotion_optional &x);

	//@}

	/**
   * @name baseForceTime
   *
   * @brief Accessor and modifier functions for the %baseForceTime
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal baseForceTime_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<baseForceTime_type> baseForceTime_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<baseForceTime_type, char, ::xsd::cxx::tree::schema_type::decimal>
		baseForceTime_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const baseForceTime_optional &
	baseForceTime() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	baseForceTime_optional &
	baseForceTime();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	baseForceTime(const baseForceTime_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	baseForceTime(const baseForceTime_optional &x);

	//@}

	/**
   * @name rZero
   *
   * @brief Accessor and modifier functions for the %rZero
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal rZero_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<rZero_type> rZero_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<rZero_type, char, ::xsd::cxx::tree::schema_type::decimal> rZero_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const rZero_optional &
	rZero() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	rZero_optional &
	rZero();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	rZero(const rZero_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	rZero(const rZero_optional &x);

	//@}

	/**
   * @name stiffnessConstant
   *
   * @brief Accessor and modifier functions for the %stiffnessConstant
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal stiffnessConstant_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<stiffnessConstant_type> stiffnessConstant_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<stiffnessConstant_type, char, ::xsd::cxx::tree::schema_type::decimal>
		stiffnessConstant_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const stiffnessConstant_optional &
	stiffnessConstant() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	stiffnessConstant_optional &
	stiffnessConstant();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	stiffnessConstant(const stiffnessConstant_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	stiffnessConstant(const stiffnessConstant_optional &x);

	//@}

	/**
   * @name rl
   *
   * @brief Accessor and modifier functions for the %rl
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal rl_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<rl_type> rl_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<rl_type, char, ::xsd::cxx::tree::schema_type::decimal> rl_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const rl_optional &
	rl() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	rl_optional &
	rl();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	rl(const rl_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	rl(const rl_optional &x);

	//@}

	/**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::calculatortype_t type_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const type_type &
	type() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	type_type &
	type();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	type(const type_type &x);

	/**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	type(::std::unique_ptr<type_type> p);

	//@}

	/**
   * @name Constructors
   */
	//@{

	/**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
	calculationInfo_t(const type_type &);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	calculationInfo_t(const ::xercesc::DOMElement &e,
	                  ::xml_schema::flags f = 0,
	                  ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	calculationInfo_t(const calculationInfo_t &x,
	                  ::xml_schema::flags f = 0,
	                  ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual calculationInfo_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	calculationInfo_t &
	operator=(const calculationInfo_t &x);

	//@}

	/**
   * @brief Destructor.
   */
	virtual
	~calculationInfo_t();

	// Implementation.
	//

	//@cond

protected:
	void
	parse(::xsd::cxx::xml::dom::parser<char> &,
	      ::xml_schema::flags);

protected:
	epsilon_optional epsilon_;
	sigma_optional sigma_;
	gravityFactor_optional gravityFactor_;
	brownianMotion_optional brownianMotion_;
	baseForceTime_optional baseForceTime_;
	rZero_optional rZero_;
	stiffnessConstant_optional stiffnessConstant_;
	rl_optional rl_;
	::xsd::cxx::tree::one<type_type> type_;

	//@endcond
};

/**
 * @brief Enumeration class corresponding to the %outputwriter_t
 * schema type.
 */
class outputwriter_t : public ::xml_schema::string {
public:

	/**
   * @brief Underlying enum type.
   */
	enum value {
		vtk,
		xyz
	};

	/**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
	outputwriter_t(value v);

	/**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
	outputwriter_t(const char *v);

	/**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
	outputwriter_t(const ::std::string &v);

	/**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
	outputwriter_t(const ::xml_schema::string &v);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	outputwriter_t(const ::xercesc::DOMElement &e,
	               ::xml_schema::flags f = 0,
	               ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	outputwriter_t(const ::xercesc::DOMAttr &a,
	               ::xml_schema::flags f = 0,
	               ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	outputwriter_t(const ::std::string &s,
	               const ::xercesc::DOMElement *e,
	               ::xml_schema::flags f = 0,
	               ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	outputwriter_t(const outputwriter_t &x,
	               ::xml_schema::flags f = 0,
	               ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual outputwriter_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
	outputwriter_t &
	operator=(value v);

	/**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
	virtual
	operator value() const {
		return _xsd_outputwriter_t_convert();
	}

	//@cond

protected:
	value
	_xsd_outputwriter_t_convert() const;

public:
	static const char *const _xsd_outputwriter_t_literals_[2];
	static const value _xsd_outputwriter_t_indexes_[2];

	//@endcond
};

/**
 * @brief Class corresponding to the %thermostat_info_t schema type.
 *
 * @nosubgrouping
 */
class thermostat_info_t : public ::xml_schema::type {
public:
	/**
   * @name nThermostat
   *
   * @brief Accessor and modifier functions for the %nThermostat
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::int_ nThermostat_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<nThermostat_type, char> nThermostat_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const nThermostat_type &
	nThermostat() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	nThermostat_type &
	nThermostat();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	nThermostat(const nThermostat_type &x);

	//@}

	/**
   * @name Tinit
   *
   * @brief Accessor and modifier functions for the %Tinit
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal Tinit_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<Tinit_type, char, ::xsd::cxx::tree::schema_type::decimal> Tinit_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const Tinit_type &
	Tinit() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	Tinit_type &
	Tinit();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	Tinit(const Tinit_type &x);

	//@}

	/**
   * @name Ttarget
   *
   * @brief Accessor and modifier functions for the %Ttarget
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal Ttarget_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<Ttarget_type> Ttarget_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<Ttarget_type, char, ::xsd::cxx::tree::schema_type::decimal> Ttarget_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const Ttarget_optional &
	Ttarget() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	Ttarget_optional &
	Ttarget();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	Ttarget(const Ttarget_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	Ttarget(const Ttarget_optional &x);

	//@}

	/**
   * @name deltaTemp
   *
   * @brief Accessor and modifier functions for the %deltaTemp
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal deltaTemp_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<deltaTemp_type> deltaTemp_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<deltaTemp_type, char, ::xsd::cxx::tree::schema_type::decimal> deltaTemp_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const deltaTemp_optional &
	deltaTemp() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	deltaTemp_optional &
	deltaTemp();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	deltaTemp(const deltaTemp_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	deltaTemp(const deltaTemp_optional &x);

	//@}

	/**
   * @name excludeY
   *
   * @brief Accessor and modifier functions for the %excludeY
   * optional attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::xml_schema::boolean excludeY_type;

	/**
   * @brief Attribute optional container type.
   */
	typedef ::xsd::cxx::tree::optional<excludeY_type> excludeY_optional;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<excludeY_type, char> excludeY_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const excludeY_optional &
	excludeY() const;

	/**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
	excludeY_optional &
	excludeY();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	excludeY(const excludeY_type &x);

	/**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
	void
	excludeY(const excludeY_optional &x);

	//@}

	/**
   * @name Constructors
   */
	//@{

	/**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
	thermostat_info_t(const nThermostat_type &,
	                  const Tinit_type &);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	thermostat_info_t(const ::xercesc::DOMElement &e,
	                  ::xml_schema::flags f = 0,
	                  ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	thermostat_info_t(const thermostat_info_t &x,
	                  ::xml_schema::flags f = 0,
	                  ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual thermostat_info_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	thermostat_info_t &
	operator=(const thermostat_info_t &x);

	//@}

	/**
   * @brief Destructor.
   */
	virtual
	~thermostat_info_t();

	// Implementation.
	//

	//@cond

protected:
	void
	parse(::xsd::cxx::xml::dom::parser<char> &,
	      ::xml_schema::flags);

protected:
	::xsd::cxx::tree::one<nThermostat_type> nThermostat_;
	::xsd::cxx::tree::one<Tinit_type> Tinit_;
	Ttarget_optional Ttarget_;
	deltaTemp_optional deltaTemp_;
	excludeY_optional excludeY_;

	//@endcond
};

/**
 * @brief Enumeration class corresponding to the %statistics_type_t
 * schema type.
 */
class statistics_type_t : public ::xml_schema::string {
public:

	/**
   * @brief Underlying enum type.
   */
	enum value {
		thermodynamical,
		densityVelocity
	};

	/**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
	statistics_type_t(value v);

	/**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
	statistics_type_t(const char *v);

	/**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
	statistics_type_t(const ::std::string &v);

	/**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
	statistics_type_t(const ::xml_schema::string &v);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	statistics_type_t(const ::xercesc::DOMElement &e,
	                  ::xml_schema::flags f = 0,
	                  ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	statistics_type_t(const ::xercesc::DOMAttr &a,
	                  ::xml_schema::flags f = 0,
	                  ::xml_schema::container *c = 0);

	/**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	statistics_type_t(const ::std::string &s,
	                  const ::xercesc::DOMElement *e,
	                  ::xml_schema::flags f = 0,
	                  ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	statistics_type_t(const statistics_type_t &x,
	                  ::xml_schema::flags f = 0,
	                  ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual statistics_type_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
	statistics_type_t &
	operator=(value v);

	/**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
	virtual
	operator value() const {
		return _xsd_statistics_type_t_convert();
	}

	//@cond

protected:
	value
	_xsd_statistics_type_t_convert() const;

public:
	static const char *const _xsd_statistics_type_t_literals_[2];
	static const value _xsd_statistics_type_t_indexes_[2];

	//@endcond
};

/**
 * @brief Class corresponding to the %statistics_t schema type.
 *
 * @nosubgrouping
 */
class statistics_t : public ::xml_schema::type {
public:
	/**
   * @name maxDistance
   *
   * @brief Accessor and modifier functions for the %maxDistance
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal maxDistance_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<maxDistance_type> maxDistance_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<maxDistance_type, char, ::xsd::cxx::tree::schema_type::decimal> maxDistance_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const maxDistance_optional &
	maxDistance() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	maxDistance_optional &
	maxDistance();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	maxDistance(const maxDistance_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	maxDistance(const maxDistance_optional &x);

	//@}

	/**
   * @name noBins
   *
   * @brief Accessor and modifier functions for the %noBins
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::int_ noBins_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<noBins_type> noBins_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<noBins_type, char> noBins_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const noBins_optional &
	noBins() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	noBins_optional &
	noBins();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	noBins(const noBins_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	noBins(const noBins_optional &x);

	//@}

	/**
   * @name deltaR
   *
   * @brief Accessor and modifier functions for the %deltaR
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal deltaR_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<deltaR_type> deltaR_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<deltaR_type, char, ::xsd::cxx::tree::schema_type::decimal> deltaR_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const deltaR_optional &
	deltaR() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	deltaR_optional &
	deltaR();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	deltaR(const deltaR_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	deltaR(const deltaR_optional &x);

	//@}

	/**
   * @name file
   *
   * @brief Accessor and modifier functions for the %file
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::string file_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<file_type, char> file_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const file_type &
	file() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	file_type &
	file();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	file(const file_type &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	file(::std::unique_ptr<file_type> p);

	//@}

	/**
   * @name frequency
   *
   * @brief Accessor and modifier functions for the %frequency
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::int_ frequency_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<frequency_type, char> frequency_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const frequency_type &
	frequency() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	frequency_type &
	frequency();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	frequency(const frequency_type &x);

	//@}

	/**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::statistics_type_t type_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const type_type &
	type() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	type_type &
	type();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	type(const type_type &x);

	/**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	type(::std::unique_ptr<type_type> p);

	//@}

	/**
   * @name Constructors
   */
	//@{

	/**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
	statistics_t(const file_type &,
	             const frequency_type &,
	             const type_type &);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	statistics_t(const ::xercesc::DOMElement &e,
	             ::xml_schema::flags f = 0,
	             ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	statistics_t(const statistics_t &x,
	             ::xml_schema::flags f = 0,
	             ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual statistics_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	statistics_t &
	operator=(const statistics_t &x);

	//@}

	/**
   * @brief Destructor.
   */
	virtual
	~statistics_t();

	// Implementation.
	//

	//@cond

protected:
	void
	parse(::xsd::cxx::xml::dom::parser<char> &,
	      ::xml_schema::flags);

protected:
	maxDistance_optional maxDistance_;
	noBins_optional noBins_;
	deltaR_optional deltaR_;
	::xsd::cxx::tree::one<file_type> file_;
	::xsd::cxx::tree::one<frequency_type> frequency_;
	::xsd::cxx::tree::one<type_type> type_;

	//@endcond
};

/**
 * @brief Class corresponding to the %array_int_3 schema type.
 *
 * @nosubgrouping
 */
class array_int_3 : public ::xml_schema::type {
public:
	/**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::xml_schema::int_ x_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<x_type, char> x_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const x_type &
	x() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	x_type &
	x();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	x(const x_type &x);

	//@}

	/**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::xml_schema::int_ y_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<y_type, char> y_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const y_type &
	y() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	y_type &
	y();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	y(const y_type &x);

	//@}

	/**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::xml_schema::int_ z_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<z_type, char> z_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const z_type &
	z() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	z_type &
	z();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	z(const z_type &x);

	//@}

	/**
   * @name Constructors
   */
	//@{

	/**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
	array_int_3(const x_type &,
	            const y_type &,
	            const z_type &);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	array_int_3(const ::xercesc::DOMElement &e,
	            ::xml_schema::flags f = 0,
	            ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	array_int_3(const array_int_3 &x,
	            ::xml_schema::flags f = 0,
	            ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual array_int_3 *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	array_int_3 &
	operator=(const array_int_3 &x);

	//@}

	/**
   * @brief Destructor.
   */
	virtual
	~array_int_3();

	// Implementation.
	//

	//@cond

protected:
	void
	parse(::xsd::cxx::xml::dom::parser<char> &,
	      ::xml_schema::flags);

protected:
	::xsd::cxx::tree::one<x_type> x_;
	::xsd::cxx::tree::one<y_type> y_;
	::xsd::cxx::tree::one<z_type> z_;

	//@endcond
};

/**
 * @brief Class corresponding to the %array_float_3 schema type.
 *
 * @nosubgrouping
 */
class array_float_3 : public ::xml_schema::type {
public:
	/**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::xml_schema::decimal x_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<x_type, char, ::xsd::cxx::tree::schema_type::decimal> x_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const x_type &
	x() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	x_type &
	x();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	x(const x_type &x);

	//@}

	/**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::xml_schema::decimal y_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<y_type, char, ::xsd::cxx::tree::schema_type::decimal> y_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const y_type &
	y() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	y_type &
	y();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	y(const y_type &x);

	//@}

	/**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::xml_schema::decimal z_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<z_type, char, ::xsd::cxx::tree::schema_type::decimal> z_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const z_type &
	z() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	z_type &
	z();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	z(const z_type &x);

	//@}

	/**
   * @name Constructors
   */
	//@{

	/**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
	array_float_3(const x_type &,
	              const y_type &,
	              const z_type &);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	array_float_3(const ::xercesc::DOMElement &e,
	              ::xml_schema::flags f = 0,
	              ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	array_float_3(const array_float_3 &x,
	              ::xml_schema::flags f = 0,
	              ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual array_float_3 *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	array_float_3 &
	operator=(const array_float_3 &x);

	//@}

	/**
   * @brief Destructor.
   */
	virtual
	~array_float_3();

	// Implementation.
	//

	//@cond

protected:
	void
	parse(::xsd::cxx::xml::dom::parser<char> &,
	      ::xml_schema::flags);

protected:
	::xsd::cxx::tree::one<x_type> x_;
	::xsd::cxx::tree::one<y_type> y_;
	::xsd::cxx::tree::one<z_type> z_;

	//@endcond
};

/**
 * @brief Class corresponding to the %special_particle_t schema type.
 *
 * @nosubgrouping
 */
class special_particle_t : public ::xml_schema::type {
public:
	/**
   * @name position
   *
   * @brief Accessor and modifier functions for the %position
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::array_int_3 position_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<position_type, char> position_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const position_type &
	position() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	position_type &
	position();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	position(const position_type &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	position(::std::unique_ptr<position_type> p);

	//@}

	/**
   * @name force
   *
   * @brief Accessor and modifier functions for the %force
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::array_float_3 force_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<force_type> force_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<force_type, char> force_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const force_optional &
	force() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	force_optional &
	force();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	force(const force_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	force(const force_optional &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
	void
	force(::std::unique_ptr<force_type> p);

	//@}

	/**
   * @name vel
   *
   * @brief Accessor and modifier functions for the %vel
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::array_float_3 vel_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<vel_type> vel_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<vel_type, char> vel_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const vel_optional &
	vel() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	vel_optional &
	vel();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	vel(const vel_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	vel(const vel_optional &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
	void
	vel(::std::unique_ptr<vel_type> p);

	//@}

	/**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::decimal mass_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<mass_type> mass_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<mass_type, char, ::xsd::cxx::tree::schema_type::decimal> mass_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const mass_optional &
	mass() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	mass_optional &
	mass();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	mass(const mass_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	mass(const mass_optional &x);

	//@}

	/**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::int_ type_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<type_type> type_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const type_optional &
	type() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	type_optional &
	type();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	type(const type_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	type(const type_optional &x);

	//@}

	/**
   * @name immovable
   *
   * @brief Accessor and modifier functions for the %immovable
   * optional attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::xml_schema::boolean immovable_type;

	/**
   * @brief Attribute optional container type.
   */
	typedef ::xsd::cxx::tree::optional<immovable_type> immovable_optional;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<immovable_type, char> immovable_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const immovable_optional &
	immovable() const;

	/**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
	immovable_optional &
	immovable();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	immovable(const immovable_type &x);

	/**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
	void
	immovable(const immovable_optional &x);

	//@}

	/**
   * @name membrane
   *
   * @brief Accessor and modifier functions for the %membrane
   * optional attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::xml_schema::boolean membrane_type;

	/**
   * @brief Attribute optional container type.
   */
	typedef ::xsd::cxx::tree::optional<membrane_type> membrane_optional;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<membrane_type, char> membrane_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const membrane_optional &
	membrane() const;

	/**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
	membrane_optional &
	membrane();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	membrane(const membrane_type &x);

	/**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
	void
	membrane(const membrane_optional &x);

	//@}

	/**
   * @name Constructors
   */
	//@{

	/**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
	special_particle_t(const position_type &);

	/**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
	special_particle_t(::std::unique_ptr<position_type>);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	special_particle_t(const ::xercesc::DOMElement &e,
	                   ::xml_schema::flags f = 0,
	                   ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	special_particle_t(const special_particle_t &x,
	                   ::xml_schema::flags f = 0,
	                   ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual special_particle_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	special_particle_t &
	operator=(const special_particle_t &x);

	//@}

	/**
   * @brief Destructor.
   */
	virtual
	~special_particle_t();

	// Implementation.
	//

	//@cond

protected:
	void
	parse(::xsd::cxx::xml::dom::parser<char> &,
	      ::xml_schema::flags);

protected:
	::xsd::cxx::tree::one<position_type> position_;
	force_optional force_;
	vel_optional vel_;
	mass_optional mass_;
	type_optional type_;
	immovable_optional immovable_;
	membrane_optional membrane_;

	//@endcond
};

/**
 * @brief Class corresponding to the %simulation_t schema type.
 *
 * @nosubgrouping
 */
class simulation_t : public ::xml_schema::type {
public:
	/**
   * @name container
   *
   * @brief Accessor and modifier functions for the %container
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::containerinfo_t container_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<container_type, char> container_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const container_type &
	container() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	container_type &
	container();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	container(const container_type &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	container(::std::unique_ptr<container_type> p);

	//@}

	/**
   * @name calculator
   *
   * @brief Accessor and modifier functions for the %calculator
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::calculationInfo_t calculator_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<calculator_type, char> calculator_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const calculator_type &
	calculator() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	calculator_type &
	calculator();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	calculator(const calculator_type &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	calculator(::std::unique_ptr<calculator_type> p);

	//@}

	/**
   * @name inputFile
   *
   * @brief Accessor and modifier functions for the %inputFile
   * sequence element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::string inputFile_type;

	/**
   * @brief Element sequence container type.
   */
	typedef ::xsd::cxx::tree::sequence<inputFile_type> inputFile_sequence;

	/**
   * @brief Element iterator type.
   */
	typedef inputFile_sequence::iterator inputFile_iterator;

	/**
   * @brief Element constant iterator type.
   */
	typedef inputFile_sequence::const_iterator inputFile_const_iterator;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<inputFile_type, char> inputFile_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
	const inputFile_sequence &
	inputFile() const;

	/**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
	inputFile_sequence &
	inputFile();

	/**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
	void
	inputFile(const inputFile_sequence &s);

	//@}

	/**
   * @name generatorFile
   *
   * @brief Accessor and modifier functions for the %generatorFile
   * sequence element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::string generatorFile_type;

	/**
   * @brief Element sequence container type.
   */
	typedef ::xsd::cxx::tree::sequence<generatorFile_type> generatorFile_sequence;

	/**
   * @brief Element iterator type.
   */
	typedef generatorFile_sequence::iterator generatorFile_iterator;

	/**
   * @brief Element constant iterator type.
   */
	typedef generatorFile_sequence::const_iterator generatorFile_const_iterator;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<generatorFile_type, char> generatorFile_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
	const generatorFile_sequence &
	generatorFile() const;

	/**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
	generatorFile_sequence &
	generatorFile();

	/**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
	void
	generatorFile(const generatorFile_sequence &s);

	//@}

	/**
   * @name outputFile
   *
   * @brief Accessor and modifier functions for the %outputFile
   * required element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::string outputFile_type;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<outputFile_type, char> outputFile_traits;

	/**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
	const outputFile_type &
	outputFile() const;

	/**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
	outputFile_type &
	outputFile();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	outputFile(const outputFile_type &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	outputFile(::std::unique_ptr<outputFile_type> p);

	//@}

	/**
   * @name generatorInfo
   *
   * @brief Accessor and modifier functions for the %generatorInfo
   * sequence element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::generator_info_t generatorInfo_type;

	/**
   * @brief Element sequence container type.
   */
	typedef ::xsd::cxx::tree::sequence<generatorInfo_type> generatorInfo_sequence;

	/**
   * @brief Element iterator type.
   */
	typedef generatorInfo_sequence::iterator generatorInfo_iterator;

	/**
   * @brief Element constant iterator type.
   */
	typedef generatorInfo_sequence::const_iterator generatorInfo_const_iterator;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<generatorInfo_type, char> generatorInfo_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
	const generatorInfo_sequence &
	generatorInfo() const;

	/**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
	generatorInfo_sequence &
	generatorInfo();

	/**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
	void
	generatorInfo(const generatorInfo_sequence &s);

	//@}

	/**
   * @name thermostat
   *
   * @brief Accessor and modifier functions for the %thermostat
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::thermostat_info_t thermostat_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<thermostat_type> thermostat_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<thermostat_type, char> thermostat_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const thermostat_optional &
	thermostat() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	thermostat_optional &
	thermostat();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	thermostat(const thermostat_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	thermostat(const thermostat_optional &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
	void
	thermostat(::std::unique_ptr<thermostat_type> p);

	//@}

	/**
   * @name checkpointInput
   *
   * @brief Accessor and modifier functions for the %checkpointInput
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::string checkpointInput_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<checkpointInput_type> checkpointInput_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<checkpointInput_type, char> checkpointInput_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const checkpointInput_optional &
	checkpointInput() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	checkpointInput_optional &
	checkpointInput();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	checkpointInput(const checkpointInput_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	checkpointInput(const checkpointInput_optional &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
	void
	checkpointInput(::std::unique_ptr<checkpointInput_type> p);

	//@}

	/**
   * @name checkpointOutput
   *
   * @brief Accessor and modifier functions for the %checkpointOutput
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::xml_schema::string checkpointOutput_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<checkpointOutput_type> checkpointOutput_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<checkpointOutput_type, char> checkpointOutput_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const checkpointOutput_optional &
	checkpointOutput() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	checkpointOutput_optional &
	checkpointOutput();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	checkpointOutput(const checkpointOutput_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	checkpointOutput(const checkpointOutput_optional &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
	void
	checkpointOutput(::std::unique_ptr<checkpointOutput_type> p);

	//@}

	/**
   * @name statistics
   *
   * @brief Accessor and modifier functions for the %statistics
   * optional element.
   */
	//@{

	/**
   * @brief Element type.
   */
	typedef ::statistics_t statistics_type;

	/**
   * @brief Element optional container type.
   */
	typedef ::xsd::cxx::tree::optional<statistics_type> statistics_optional;

	/**
   * @brief Element traits type.
   */
	typedef ::xsd::cxx::tree::traits<statistics_type, char> statistics_traits;

	/**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const statistics_optional &
	statistics() const;

	/**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
	statistics_optional &
	statistics();

	/**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
	void
	statistics(const statistics_type &x);

	/**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
	void
	statistics(const statistics_optional &x);

	/**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
	void
	statistics(::std::unique_ptr<statistics_type> p);

	//@}

	/**
   * @name t_end
   *
   * @brief Accessor and modifier functions for the %t_end
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::xml_schema::decimal t_end_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<t_end_type, char, ::xsd::cxx::tree::schema_type::decimal> t_end_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const t_end_type &
	t_end() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	t_end_type &
	t_end();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	t_end(const t_end_type &x);

	//@}

	/**
   * @name delta_t
   *
   * @brief Accessor and modifier functions for the %delta_t
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::xml_schema::decimal delta_t_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<delta_t_type, char, ::xsd::cxx::tree::schema_type::decimal> delta_t_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const delta_t_type &
	delta_t() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	delta_t_type &
	delta_t();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	delta_t(const delta_t_type &x);

	//@}

	/**
   * @name writeFrequency
   *
   * @brief Accessor and modifier functions for the %writeFrequency
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::xml_schema::int_ writeFrequency_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<writeFrequency_type, char> writeFrequency_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const writeFrequency_type &
	writeFrequency() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	writeFrequency_type &
	writeFrequency();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	writeFrequency(const writeFrequency_type &x);

	//@}

	/**
   * @name outputWriter
   *
   * @brief Accessor and modifier functions for the %outputWriter
   * required attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::outputwriter_t outputWriter_type;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<outputWriter_type, char> outputWriter_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
	const outputWriter_type &
	outputWriter() const;

	/**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
	outputWriter_type &
	outputWriter();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	outputWriter(const outputWriter_type &x);

	/**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
	void
	outputWriter(::std::unique_ptr<outputWriter_type> p);

	//@}

	/**
   * @name parallelization
   *
   * @brief Accessor and modifier functions for the %parallelization
   * optional attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::parallel_t parallelization_type;

	/**
   * @brief Attribute optional container type.
   */
	typedef ::xsd::cxx::tree::optional<parallelization_type> parallelization_optional;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<parallelization_type, char> parallelization_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const parallelization_optional &
	parallelization() const;

	/**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
	parallelization_optional &
	parallelization();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	parallelization(const parallelization_type &x);

	/**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
	void
	parallelization(const parallelization_optional &x);

	/**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
	void
	parallelization(::std::unique_ptr<parallelization_type> p);

	//@}

	/**
   * @name random
   *
   * @brief Accessor and modifier functions for the %random
   * optional attribute.
   */
	//@{

	/**
   * @brief Attribute type.
   */
	typedef ::xml_schema::boolean random_type;

	/**
   * @brief Attribute optional container type.
   */
	typedef ::xsd::cxx::tree::optional<random_type> random_optional;

	/**
   * @brief Attribute traits type.
   */
	typedef ::xsd::cxx::tree::traits<random_type, char> random_traits;

	/**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
	const random_optional &
	random() const;

	/**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
	random_optional &
	random();

	/**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
	void
	random(const random_type &x);

	/**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
	void
	random(const random_optional &x);

	//@}

	/**
   * @name Constructors
   */
	//@{

	/**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
	simulation_t(const container_type &,
	             const calculator_type &,
	             const outputFile_type &,
	             const t_end_type &,
	             const delta_t_type &,
	             const writeFrequency_type &,
	             const outputWriter_type &);

	/**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
	simulation_t(::std::unique_ptr<container_type>,
	             ::std::unique_ptr<calculator_type>,
	             const outputFile_type &,
	             const t_end_type &,
	             const delta_t_type &,
	             const writeFrequency_type &,
	             const outputWriter_type &);

	/**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
	simulation_t(const ::xercesc::DOMElement &e,
	             ::xml_schema::flags f = 0,
	             ::xml_schema::container *c = 0);

	/**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	simulation_t(const simulation_t &x,
	             ::xml_schema::flags f = 0,
	             ::xml_schema::container *c = 0);

	/**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
	virtual simulation_t *
	_clone(::xml_schema::flags f = 0,
	       ::xml_schema::container *c = 0) const;

	/**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
	simulation_t &
	operator=(const simulation_t &x);

	//@}

	/**
   * @brief Destructor.
   */
	virtual
	~simulation_t();

	// Implementation.
	//

	//@cond

protected:
	void
	parse(::xsd::cxx::xml::dom::parser<char> &,
	      ::xml_schema::flags);

protected:
	::xsd::cxx::tree::one<container_type> container_;
	::xsd::cxx::tree::one<calculator_type> calculator_;
	inputFile_sequence inputFile_;
	generatorFile_sequence generatorFile_;
	::xsd::cxx::tree::one<outputFile_type> outputFile_;
	generatorInfo_sequence generatorInfo_;
	thermostat_optional thermostat_;
	checkpointInput_optional checkpointInput_;
	checkpointOutput_optional checkpointOutput_;
	statistics_optional statistics_;
	::xsd::cxx::tree::one<t_end_type> t_end_;
	::xsd::cxx::tree::one<delta_t_type> delta_t_;
	::xsd::cxx::tree::one<writeFrequency_type> writeFrequency_;
	::xsd::cxx::tree::one<outputWriter_type> outputWriter_;
	parallelization_optional parallelization_;
	random_optional random_;

	//@endcond
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

/**
 * @name Parsing functions for the %simulation document root.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::simulation_t>
simulation(const ::std::string &uri,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t>
simulation(const ::std::string &uri,
           ::xml_schema::error_handler &eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t>
simulation(const ::std::string &uri,
           ::xercesc::DOMErrorHandler &eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::simulation_t>
simulation(::std::istream &is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t>
simulation(::std::istream &is,
           ::xml_schema::error_handler &eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t>
simulation(::std::istream &is,
           ::xercesc::DOMErrorHandler &eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::simulation_t>
simulation(::std::istream &is,
           const ::std::string &id,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t>
simulation(::std::istream &is,
           const ::std::string &id,
           ::xml_schema::error_handler &eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t>
simulation(::std::istream &is,
           const ::std::string &id,
           ::xercesc::DOMErrorHandler &eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::simulation_t>
simulation(::xercesc::InputSource &is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t>
simulation(::xercesc::InputSource &is,
           ::xml_schema::error_handler &eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t>
simulation(::xercesc::InputSource &is,
           ::xercesc::DOMErrorHandler &eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 */
::std::unique_ptr<::simulation_t>
simulation(const ::xercesc::DOMDocument &d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::unique_ptr<::simulation_t>
simulation(::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties &p = ::xml_schema::properties());

//@}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<<(::xercesc::DOMElement &, const parallel_t &);

void
operator<<(::xercesc::DOMAttr &, const parallel_t &);

void
operator<<(::xml_schema::list_stream &,
           const parallel_t &);

void
operator<<(::xercesc::DOMElement &, const geometric_t &);

void
operator<<(::xercesc::DOMAttr &, const geometric_t &);

void
operator<<(::xml_schema::list_stream &,
           const geometric_t &);

void
operator<<(::xercesc::DOMElement &, const border_single_t &);

void
operator<<(::xercesc::DOMAttr &, const border_single_t &);

void
operator<<(::xml_schema::list_stream &,
           const border_single_t &);

void
operator<<(::xercesc::DOMElement &, const border_t &);

void
operator<<(::xercesc::DOMElement &, const behaviour_t &);

void
operator<<(::xercesc::DOMAttr &, const behaviour_t &);

void
operator<<(::xml_schema::list_stream &,
           const behaviour_t &);

void
operator<<(::xercesc::DOMElement &, const generator_info_t &);

void
operator<<(::xercesc::DOMElement &, const containertype_t &);

void
operator<<(::xercesc::DOMAttr &, const containertype_t &);

void
operator<<(::xml_schema::list_stream &,
           const containertype_t &);

void
operator<<(::xercesc::DOMElement &, const calculatortype_t &);

void
operator<<(::xercesc::DOMAttr &, const calculatortype_t &);

void
operator<<(::xml_schema::list_stream &,
           const calculatortype_t &);

void
operator<<(::xercesc::DOMElement &, const containerinfo_t &);

void
operator<<(::xercesc::DOMElement &, const calculationInfo_t &);

void
operator<<(::xercesc::DOMElement &, const outputwriter_t &);

void
operator<<(::xercesc::DOMAttr &, const outputwriter_t &);

void
operator<<(::xml_schema::list_stream &,
           const outputwriter_t &);

void
operator<<(::xercesc::DOMElement &, const thermostat_info_t &);

void
operator<<(::xercesc::DOMElement &, const statistics_type_t &);

void
operator<<(::xercesc::DOMAttr &, const statistics_type_t &);

void
operator<<(::xml_schema::list_stream &,
           const statistics_type_t &);

void
operator<<(::xercesc::DOMElement &, const statistics_t &);

void
operator<<(::xercesc::DOMElement &, const array_int_3 &);

void
operator<<(::xercesc::DOMElement &, const array_float_3 &);

void
operator<<(::xercesc::DOMElement &, const special_particle_t &);

void
operator<<(::xercesc::DOMElement &, const simulation_t &);

/**
 * @name Serialization functions for the %simulation document root.
 */
//@{

/**
 * @brief Serialize to a standard output stream.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
simulation(::std::ostream &os,
           const ::simulation_t &x,
           const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
           const ::std::string &e = "UTF-8",
           ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with an error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
simulation(::std::ostream &os,
           const ::simulation_t &x,
           ::xml_schema::error_handler &eh,
           const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
           const ::std::string &e = "UTF-8",
           ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with a Xerces-C++ DOM
 * error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
simulation(::std::ostream &os,
           const ::simulation_t &x,
           ::xercesc::DOMErrorHandler &eh,
           const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
           const ::std::string &e = "UTF-8",
           ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
simulation(::xercesc::XMLFormatTarget &ft,
           const ::simulation_t &x,
           const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
           const ::std::string &e = "UTF-8",
           ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with an error
 * handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
simulation(::xercesc::XMLFormatTarget &ft,
           const ::simulation_t &x,
           ::xml_schema::error_handler &eh,
           const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
           const ::std::string &e = "UTF-8",
           ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with a
 * Xerces-C++ DOM error handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
simulation(::xercesc::XMLFormatTarget &ft,
           const ::simulation_t &x,
           ::xercesc::DOMErrorHandler &eh,
           const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
           const ::std::string &e = "UTF-8",
           ::xml_schema::flags f = 0);

/**
 * @brief Serialize to an existing Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param x An object model to serialize.
 * @param f Serialization flags.
 *
 * Note that it is your responsibility to create the DOM document
 * with the correct root element as well as set the necessary
 * namespace mapping attributes.
 */
void
simulation(::xercesc::DOMDocument &d,
           const ::simulation_t &x,
           ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a new Xerces-C++ DOM document.
 *
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param f Serialization flags.
 * @return A pointer to the new Xerces-C++ DOM document.
 */
::xml_schema::dom::unique_ptr<::xercesc::DOMDocument>
simulation(const ::simulation_t &x,
           const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
           ::xml_schema::flags f = 0);

//@}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // SIMULATION_H
